[
["index.html", "This is us: making CSAFE stronger each week Chapter 1 Prerequisites", " This is us: making CSAFE stronger each week CSAFE 2019-10-31 Chapter 1 Prerequisites This is a sample book written in Markdown. You can use anything that Pandoc’s Markdown supports, e.g., a math equation \\(a^2 + b^2 = c^2\\). The bookdown package can be installed from CRAN or Github: install.packages(&quot;bookdown&quot;) # or the development version # devtools::install_github(&quot;rstudio/bookdown&quot;) Remember each Rmd file contains one and only one chapter, and a chapter is defined by the first-level heading #. To compile this example to PDF, you need XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.name/tinytex/. "],
["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction This section will become the section for the administrative updates/organization once we have figured out how to use all of the bookdown features for our purposes. You can label chapter and section titles using {#label} after them, e.g., we can reference Chapter 2. If you do not manually label them, there will be automatic labels anyway, e.g., Chapter ??. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 2.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 2.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 2.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 2.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa You can write citations, too. For example, we are using the bookdown package (Xie 2019) in this sample book, which was built on top of R Markdown and knitr (Xie 2015). References "],
["bullets.html", "Chapter 3 Project CC: Bullets and Cartridge Cases 3.1 Data Collection 3.2 Computational Tools 3.3 Similarity Scores 3.4 Analysis of Results 3.5 Communication of Results and Methods 3.6 People involved", " Chapter 3 Project CC: Bullets and Cartridge Cases For both bullets and cartridge cases we are dealing with several inter-related aspects, that we want to address independently. Those are: data collection computational tools similarity scores for bullet lands: crosscut identification groove location curvature removal alignment of signatures feature extraction matching with trained Random Forest for breech faces analysis of results communication of results and methods 3.1 Data Collection 3.1.1 LAPD All bullets are collected by Srinivasan Rathinam, LAPD. 3.1.1.1 Main study 4 bullets per barrel for 626 Beretta 92 F/FS firearms , ammunition used are 9 mm Luger Winchester 115 grain with a Copper surface. scans are on Raven. evaluation: Yawei is going to work through all 626 barrels of knowns to assess similarity scores Figure 3.1: Results from assessing scans of barrel FAU 1 similarity. Figure 3.2: Results from assessing scans of barrel FAU 2 similarity. Why some of the cases failed? (181/626 = 30%) x3p_crosscut_optimize() failed to find the positions to get cross cut for some lands. Figure 3.3: Land scan for barrel FAU 3 bullet A land 6. Figure 3.4: Land scan for barrel FAU 4 bullet C land 5. Figure 3.5: Land scan for barrel FAU 5 bullet B land 5. Assess the land-land comparasion and bullet-bullet comparasion For bullet-bullet comparasion: we use the “sequence average maximum”(SAM), i.e. average ccf of “lines” of land-land comparasions, as the bullet similarity score(currently). By making use of 92 manually generated comparasion data, we try to produce the KM(known-matches) and KNM(known-non-matches) plot. For the known mathches, we have totally 626 x 6 = 3756 for the LAPD data, excluding the comparasions for same bullet. For the known non-matches, we don’t have the data in hand. We need to generate the data in a way. We have totally 626 x 625/2 x 16 = 313000 known non-matches. We can only generate a sample from the data. We sampled 100 bullet-bullet known non-matches from our 92 cases. Figure 3.6: KM and KNM Is the SAM(sequence average maximum) a good choice? Need to do a permutation test. Figure 3.7: SAM permutation result Figure 3.8: SAM permutation result among maxmum Possible dependence structure in land-land comparasions: Assume beta distributions for the ccf for both known mathces and known non-matches. For the real known match cases, we consider a mixture distribution of two/three beta distribution. Figure 3.9: KM three components for all data Figure 3.10: KNM two components for all data Figure 3.11: common component Ten-fold-cross validation (no validation yet), check the model estimator sensibility Figure 3.12: KM ten-fold models for two components Figure 3.13: KM ten-fold models for three components Figure 3.14: KNM ten-fold models for one component Figure 3.15: KNM ten-fold models for two components Increasing sample size: 1, 2, 6, 12, … number of barrels Figure 3.16: KM increasing sample models for two components Figure 3.17: KNM increasing sample models for one components Figure 3.18: KM increasing sample for first component More on the weight Figure 3.19: Prior weight on components More on one barrel case Figure 3.20: KM one barrel model for the frist ten barrels Some conclusions from current plots: Generally, the fits are stable in both ten-fold-cross validation and increasing sample cases In ten-fold model, group8 model behaves a little different from others when in three components case In increasing sample models, the one barrel model is not stable, but the one in our case is still a rarare case The three components model for KM is less stable than two components one especially in small sample cases Two components model for KNM is not stable in small sample case(in terms of weight) Figure 3.21: ROC-cv-models Figure 3.22: ROC-different-size-models Figure 3.23: ROC-one-barrel Figure 3.24: KM-table Figure 3.25: KNM-table 3.1.1.2 follow-up study 4 bullets per barrel for 96 of the original 626 Beretta firearms using different ammunition bullets are being scanned 3.1.2 Hamby Sets Scans for Hamby Sets 10, 36, 44, and 224 Scans for 3 replicates of clones for Hamby 224 3.1.3 Houston Tests contact: Melissa Nally, Houston FSI 3.1.3.1 Pre-study 3 kits with 23 bullets each Figure 3.26: Bullet-to-bullet similarity scores for questioned bullets (y-axis) compared to all other bullets of the test set (x-axis). evaluation included in submission to JFI 3.1.3.2 Study 4 kits with 20 bullets each scans done, evaluation finished, some scans of doubtful quality 3.1.4 Houston Persistence contact: Melissa Nally, Houston FSI 8 barrels with 40 fired bullets each 3.1.5 St Louis persistence contact: Steve Kramer, St Louis PD 2 barrels with 192 fired bullets each (2 bullets collected every 25 shots) 3.1.6 DFSC Cartridge cases Breech face data for knowns are scanned and available on a private github repository evaluation 3.2 Computational Tools 3.2.1 x3ptools x3ptools is an R package for working with files in x3p format. x3p is an ISO standard for describing 3d topographic surface measurements. x3ptools is available on CRAN, i.e. can be installed with the command install.packages(&quot;x3ptools&quot;). The development version is available from github. Installation instructions and basic usage can be found at https://heike.github.io/x3ptools/ 3.2.2 bulletxtrctr bulletxtrctr is a developmental R package available from github (see https://heike.github.io/bulletxtrctr/) that allows an assessment of similarity scores using the data extraction pipeline described in Hare, Hofmann, and Carriquiry (2016). 3.2.3 grooveFinder grooveFinder is a developmental R package providing different methods for identifying the location of grooves in scans of bullets. Installation instructions and some basic usage can be found at https://heike.github.io/grooveFinder/ 3.3 Similarity Scores 3.3.1 Bullet Lands 3.3.1.1 Approaches to identify groove locations 3.3.1.1.1 Hough Transform Method for Identifying Grooves Charlotte 9/5/19 Update: State semester goals and iron out inconsistencies with 2-d and 3-d visualizations due to unit changes. Current Goals: - Iron-out issues with consistency of units with get_hough_grooves. I believe there are some issues translating from the 2-d visualization to the 3-d visualization that might have to do with inconsistent unit inputs? For Example Figure 3.27: 2-dimensional visualization of example bullet br411 with .999 strength threshold Figure 3.28: 3-dimensional visualization of example bullet br411 with .999 strength threshold So either somethin is wrong with get_mask_hough or something is funky with the units. Also need to think of including a sort of rounding component where lines with slopes that are practically infinite can be viewed as a vertical line Compare Hough results with manual identification using score calculations from Kiegan. Write up results in Hough Groove Paper (It’s coming I promise) Create graphical images to explain line selection method Include 2-d and 3-d visualizations of Hough groove area identifications Include crosscut visualization and comparison in results Charlotte update 09/12/19: This week I have been working on obtaining some results for the Phoenix set on Sunny. As a minor update the unit issues in get_mask_hough() are resolved ( I think). Below is an example of a nice image that has been generated using masks. Figure 3.29: Phoenix Gun1 A-9 B1 Land 4 generated at strength threshold of 0.99, initially did not generate estimates at the 0.999 or 0.995 level However the mask is only as good as the Hough estimates that supports it as shown here (less nice). Figure 3.30: Phoenix Gun1 F-6 B2 Land 5 generated at strength threshold of 0.9, initially did not generate estimates at the 0.999 or 0.995, or 0.99 level Hough crosscut predictions for the Phoenix dataset are now uploaded to the bulletQuality Github in the“results” folder and contains Hough groove estimates at the following five strength levels: 0.999, 0.995, 0.99, 0.95, 0.9. The source and the crosscut estimate are also included in the dataset. Here are some preliminary results of using Kiegan’s area of misidentification method (thanks Kiegan!) on Hough groove estimates at the strength threshold of 0.999 in comparison to the BCP and Lasso method. Figure 3.31: Left-hand groove area of misidentification log-transformed scores for BCP, Lasso, and Hough Figure 3.32: Right-hand groove area of misidentification log-transformed scores for BCP, Lasso, and Hough These scoresare log transformed to show better separation but it’s very clear that for the left groove both Lasso and BCP are out performing the Hough method in correctly identifying grooves. For the righthand side, scores tend to be more similar however once again, the Lasso method seems to bo the best job since it has a larger density of low scores and minimizes high score misidenfitications. For improvement before next week, I will investigate why there are 47 missing Hough predictions resulting in a score of 0 in these results and change the parameters in the get_grooves_hough() function to try and generate estimates for some of those missing values. Charlotte update 09/19/2019: This week we are trying to think of a new way for selecting Hough lines for bullet estimates. The previous method for selecting Hough lines was to find lines with x-intercepts at the top and bottom of the lands closest to the lower and upper one sixth of the bullet lands. However this process was highly dependent on score thresholding from the Hough transform which is frustrating when running a large number of bullets since if the right score threshold was not achieved, no result would be produced. So right now I’m working on a way of selecting Hough lines from the normalized Hough scores. To obtain a normalized Hough score I take the x-intercepts of each estimated Hough line generate and find the distance between the x-intercept at the top and the bottom of the land. This should give me the max possible score for each Hough line, rather than calculating based on theta. Then I take the Hough score and divide by this maximum to normalize scores between 0 and 1. Right now I am working on visualizing some of these results but my code is buggy because I’m getting negative values when I try to visualize the process using masks when I shouldn’t. Here is an example of a bullet land using the old and new method. Really similar results although it would appear that the new resut places the Hough transform lines further in to interior of the land than the old results. So that’s promising? Figure 3.33: Phoenix Gun 1-A9 Bullet 3 Land 1 visualized using current Hough process message Figure 3.34: Phoenix Gun 1-A9 Bullet 3 Land 1 visualized using new Hough process message Charlotte Update 09/26/2019: This week is focused on fixing the normalization of the scores for Hough grooves. So that the process can be automatic rather than rely on manual input for the score threshold. Instead of dividing by the geometric distance between the top and bottom intercepts of the bullet image. Now we only consider Hough lines that actually go through both the top and bottom of the land, therefore we can normalize each score by dividing the original hough score by the height of the image and multiplied by the cosine of theta which accounts for the difference in length of lines with differing angles. As far as selecting normalized scores from every score possible I found that there is really no visual difference between selecting the highest normalized Hough score and the other top five. Figure 3.35: Phoenix Gun 1-A9 Land 4 visualized using new Hough process index one Figure 3.36: Phoenix Gun 1-A9 Land 4 visualized using new Hough process index ten Figure 3.37: Phoenix Gun 1-A9 Land 4 visualized using new Hough process index twenty So for now we will continue to select the highest normalized Hough score to use as our bullet land estimates. After fixing the parameterization of the Hough scores and how we normalize Hough scores, the 3-dimensional images appear to have improved! Which is great news since no thresholding was necessary. Figure 3.38: Hamby Bullet 1 Land 1 visualized using new Hough process Still we run into the problem that our masks are only as good as our estimates, however even this terrible bullet land appears to have grooves identified somewhat well. Figure 3.39: Hamby Bullet 1 Land 4 visualized using new Hough process A comparison between the two methods finds that generally the new Hough process out-competes the old one on nearly every bullet land in the Hamby 252 demo set. Figure 3.40: Crosscut Results Hamby 252 Demo Set Comparison between old and new methods Charlotte Update 10/3/2019: The get_grooves_hough function has changed since last week, it previously slopes were calculated in x which is numerically less stable than a slope in y so for example when we were using the old slopes we had the possibility of dividing by zero which is not good. Changing to the new slope helps eliminate that likelihood. Other than that I am working on writing a grooveFinder vignette. I will be discussing every step of the Hough algorithm at length then demonstrating the function itself on the Hamby44 demo set. Charlotte Update 10/3/2019: Finished up the application section of the Hough grooves vignette, need to fill in a few demonstration images that explane how we calculate normalized scores using geometry. Now working on: - Finish visualization portion for the vignette - Expand testing for get_grooves_hough Charlotte Update 10/17/2019: Finally finished up with the vignette, but need to finish one or two more explanation diagrams before first-pass is complete. Having trouble figuring out what the results section should really look like. Need to finish tests for get_grooves_hough. Charlotte Update 10/22/2019: For this weeks spotlight I will focus on motivating the reasoning behind the Hough project, a demonstration of mechanics or how the function actually works and maybe a few results. 3.3.1.1.2 Project Motivation One of the main objectives of the bullet project is to develop algorithms that can match bullet lands based on a set of features taken from a signature of a single bullet crosscut. In order to to extract these vital signatures we need to fit a robust loess to our crosscut data to remove the curvature inherent in each bullet land. However, there-in lies a problem. If the groove engraved areas are included in our fitting of the robust loess we observe boundary effects that negatively impact the accuracy of the extracted signature. So a key goal in the bullet project is to be able to automatically identify the location of bullet grooves. Other projects in pursuit of this goal use a statistical approach to calculating the location of bullet grooves over a single crosscut. However, we are given an entire land scan in the form of an x3p file. By using low-level image algorithms like the Hough transform, we can almost make full utility of the x3p scan by estimating bullet grooves over the entire bullet land image instead of a single crosscut. 3.3.1.1.3 Hough Transform Mechanics Hough transforms are essentially a computer algorithm for detecting imperfect incidences of a known class of shapes in an image by finding aligned points. In our case, grooves are typically linear so we want the Hough transform to detect straight lines. Anyone who has looked at a bullet scan knows that the striae are also straight lines, so some image pre-processing is necessary for the algorithm to be able to distinguish between weaker appearing striae and the prominent groove features. Traditionally a gaussian blur and Canny Edge detection are performed to reduce the noise found in a gradient image. However, we have found that using Canny Edge detection is pretty much unnecessary for identifying grooves. Figure 3.41: Bullet land with Canny Edge detection Figure 3.42: Same bullet land but only with gradient magnitude thresholding at the 99th percentile Utilizing the cleaned up edges in our bullet image, the Hough transform cycles through every pixel of an image in an attempt to find aligned points on an edge. To do so, the Hough transform operates by transforming each point in a line into a different feature space. Figure 3.43: Diagram of detecting aligned points by looking for intersections in the feature space. Source: ‘How Hough Transform Works’- Thales Sehn Körting Unfortunately, vertical lines have slopes in x that tend to infinity, which would make storing the results of the Hough transform impossible due to memory storage issues. So the Hough transform parameterizes lines in what is known as the Hessian Normal Form. \\[ \\rho = x\\ \\cos(\\theta) \\ + \\ y\\ \\sin(\\theta)\\] Figure 3.44: Hessian Normal Form of simple line over bullet image Figure 3.45: Gif of a Hough Transform Algorithm at work. Source: ‘How Hough Transform Works’ - Thales Sehn Körting So the output of the Hough algorithm (in this package we utilize the hough_lines function from the imager package) is thus a set of \\(\\rho\\) and \\(\\theta\\) that define the detected lines but also a “score” which indicates the number of points that the algorithm detected for this particular edge estimation. This allows us to use thresholding and other means to select only the strongest candidates as groove estimates. Previous iterations of the get_hough_grooves function used a user-specified score thresholding level which made results highly variable dependent on the inputted score threshold. Now we use a normalized “score” to select the strongest line detected in the image. Once our lines for the left-hand and right-hand grooves are selected, we choose to output two functions that define our estimated grooves. To compute the parameters of our Hough line, we first find the location of where each line first intersects the bullet (“xtop”) then we use our known “xtop” and our known “height” of the image to calculate “xbottom” using good ol’ SOH CAH TOA. Figure 3.46: Geometrically Calculating ‘xbottom’ The reason for calculating the top and bottom intersection points is so that we can derive a slope for our groove estimate in y. When we learned how to calculate slope in grade school, we were always taught to use “rise over run” which is slope in x. However when the lines are vertical, we are essentially dividing the height of our bullet land by 0 to obtain a slope. So it is numerically more stable to define the slope as \\(\\frac{(\\text{xtop - xbottom})}{\\text{height}}\\) so vertical lines simply have a slope of 0. 3.3.1.1.4 Implementation As far as implementation goes, the function get_grooves_hough takes care of the edge detection, Hough algorithm, and line selection. Similar to other methods used for detecting lines, the get_grooves_hough function has an adjust parameter that allows the user to specify how far inward they want to “nudge” the groove estimates. The default for the Hough transform is set at 10, however this needs to be experimented with for a variety of different bullets to find appropriate adjust levels. Figure 3.47: 3d visualization of example bullet 3.3.1.1.5 What’s Next? Fiddling with adjusts and how it affects score. To find an optimal adjust for the Phoenix set, I calculate the default Hough groove estimates then find what the estimate would be for a series of adjusts. Naively I have defined a new parameter called “difference_left” and “difference_right” which is simply the difference between the manually identified groove location at an optimized crosscut and our Hough estimate at a particular adjust level. For now, I have defined any negative values to indicate that the Hough estimate is further from the center than the identified truth. So we want to minimize these negative difference to better get rid of boundary effects. Figure 3.48: Difference between the left hand Hough estimate and the truth at various adjusts Figure 3.49: Difference between the righ hand Hough estimate and the truth at various adjusts 3.3.1.1.6 LASSO Method A paper is in preparation for submission to Forensic Science International describing this method (get_grooves_lassofull in grooveFinder), as well as the Bayesian changepoint method (get_grooves_bcp). 3.3.1.1.7 Robust LOESS Method A paper submitted to the Journal of Forensic Science is waiting for peer review response to the first round of revisions. 3.3.1.2 Bullet Land Comparisons Pipeline Most data analysis processes can be thought of as a data analysis “pipeline”. This process can involve data collection, decisions about data cleaning, data transformation or reduction, and feature engineering. For example, consider the general process below: In the case of the bullet project, we have a pipeline which starts with having two physical bullet LEAs and ends with a quantitative result, a random forest similarity score. Our pipeline could be described (roughly) as something like this: To make this a little easier to see, we can look at how a 3D scan is processed into a 2D signature: Now, something important to consider is whether each of these “data decisions” has an impact on the quantitative result (here, a similarity score between two LEA signatures). Consider a simple set of decisions we could make in our bullet pipeline: If we have a pair of signatures, we could theoretically end up with 16 different similarity scores depending on the decisions we make at each point. That is also assuming that both signatures were processed in the same way at each point. This year, I’ll be studying our bullet land “pipeline” here at CSAFE, as well as pipelines that are a little different than ours (e.g., Chu et al. (2010)). There are a few major goals I am working towards: Quantifying the uncertainty of our RF similarity scores based on data decisions Comparing reproducibility/robustness of differing bullet analysis approaches Hare, Hofmann, and Carriquiry (2016) vs. Chu et al. (2010), for example Crosscuts: method 1 vs. alternate? Crosscut parameter tuning? Groove methods Original RF vs. updated/retrained/re-engineering Reproducibility/robustness of different approaches when we consider data COLLECTION. The code in bulletxtrctr is already really well set up as a data “pipeline”, so now we are conceptualizing the best way to wrap the pipeline and keep track of what decisions are made along the way. We are using few resources to conceptualize and plan the pipeline work, including: tidymodels, a part of the tidyverse focused on design matrices and reproducibility of modeling drake, an R package by Will Landau which helps cache information and keep track of steps in a pipeline We are investigating how well this scales to ``big data&quot;. It does not scale well. Some pipeline/plumbing papers by Hadley Wickham, Heike Hofmann, Dianne Cook, and others These focus on interactive graphics and updating data/plotting objects with interactivity All of the existing tools in the “bulletverse”; x3ptools, bulletxtrctr, grooveFinder, etc. Earlier this year, we designed and collected a bullet scanning variability study of 9 bullets. I’m working on formally modeling the variability at the signature level, taking two major approaches: Subsampling and assuming independence; Directly modeling out the mean structure Ignoring peak/valley dependence Using time series/spatial dependence modeling Using a Bayesian shrinkage prior (w/help from Amy!) Results for Method 1, the subsampling, looks something like this: We are also investigating the variability of random forest scores, using pairs of signatures. The current process for taking a set of signatures and completing pairwise comparisons on each of them actually completes many comparisons twice, which has two impacts: It takes up more computational time and memory than we really need it to It has the potential to make our variance component estimates inaccurate - we double-count a bunch of comparisons! Over the summer I made a function to “fix” this, to address the estimation problem in my variability study. The bulletxtrctr pipeline calls for using expand.grid. My new function compares pairs by creating a pairing_id variable and ensuring no pairing_id is duplicated. This is the resulting set of comparisons: The changes to our results are minor, but it is an important detail when modeling things. Two papers in progress! Groove ID paper #1 is waiting for reviewer scores, Groove ID paper #2 is waiting for advisor comments. Sometimes, data collection goes awry… I am in the process of documenting all the data issues and double-checking everything. We are adding more operators (and another set of bullets) to our variability study! I am in a mad dash to get more book content to Alicia and then reviewers soon. 3.3.2 Cartridge Cases 3.3.2.1 Congruent Matching Cells (CMC) algorithm for comparing cartridge case breech face impressions Joe 9/5/19 Update: Explanation of missing value problem when calculating cross-correlations and some attempted fixes. Dealing with missing values in the x3p scans continues to be an issue. The Fast Fourier Transform method for calculating cross-correlation can’t handle missing data in an image, so we’ve attempted a few “fixes” that haven’t necessarily turned out as well as expected. One idea we had was to replace the NA values in a cell with the average pixel value. However, this is artificially introducing a signal where before there was none. This can (and demonstrably has) led to inflated/incorrect correlations between cells that shouldn’t have much at all in common. Unfortunately, this may be the only solution if we still wish to adhere to the CMC algorithm as described in Song et al. (2015). One improvement that I’ve implemented is to “crop out” the rows and columns of an image that only contain NAs. This at least means that we’ve weakened the strength of the artificial signal relative to the breechface’s signal. Below is a series of images that illustrate how we might compare a cell in one image to a region of another image. Figure 3.50: Comparing a cell in image 1 to a larger region in image 2. We wish to find the translations of the image 1 cell that yield the highest correlation within the image 2 region. For the sake of an example, let’s focus on the blue outlined cell in image 1. Our goal is to use the image 1 cell to “search” a corresponding larger region in image 2 for the horizontal/vertical translations needed to produce the highest correlation. Below is a zoomed-in version of the blue outlined image 1 cell on the left and the larger image 2 region (approximately: I made the gridded image above by-hand outside of R while the images below are from R). The image 1 cell may look larger than the image 2 region, but we can see from the axes that the image 2 region is indeed larger. Any white pixels in the two images are NA values that need to be dealt with in some way before we can use FFTs to calculate the cross-correlation. Figure 3.51: (Left) A cell from image 1. (Right) A region from image 2 centered in the same location as the image 1 cell, yet quadruple the area. As already discussed above, one “solution” is to replace the NA values with the average pixel value of each image. However, to avoid creating a stronger artificial signal than necessary, we can crop-out the NA rows and columns from the two images above. Below is the cropped version of the two images. The cropping doesn’t produce signficantly different images in this case, but you could imagine other examples in which a cell has captured only small amount of breechface in the corner. Such examples are fairly common and cropping signficantly changes the resulting correlation values. Figure 3.52: The same images as above after cropping NA rows/columns. The last step before calculating correlation for these cells is to replace the remaining NAs with the average pixel value. This is shown below. Figure 3.53: The NA-cropped images with remaining NAs replaced with the image’s average pixel values. The cross-correlation is then calculated between these two images via a standard fast fourier transform process (see Cross-Correlation Theorem). The benefit of using such a process is that (as the name suggests) it’s faster than calculating the raw correlation between the two images. Also, the translations that produce the highest correlation between the image 1 cell and the image 2 region fall out of the calculation for free. This pre-processing/cross-correlation calculation procedure is repeated for every cell in image 1 that contains breech face impression. Because it is not valid to assume that the two images are rotationally aligned by default, we perform the same procedure repeatedly while rotating image 2. Currently, we perform a “rough” grid search of \\(\\theta \\in [-177.5,180]\\) by increments of \\(2.5^{\\circ}\\). Theoretically, the final results tell us how we need to horizontally/vertically translate and rotate the two images to be correctly aligned. 3.3.2.2 Congruent Matching Tori: a promising solution to the missing value problem Joe 9/5/19 Update (cont’d): A brief introduction to a congruent matching “tori” method that may provide a better solution to the missing value problem. As discussed above, dealing with missing values is provign to be a pain. The good news is that the currently-implemented CMC as described above yields results very similar to those published in Song et al. (2015) that originally describes that CMC algorithm. While our results seem to agree with currently published results, it would be nice if we could avoid needing to artifically replace missing values. We can do so if, rather than breaking up the circular breech face impression scans into disjoint squares, we break up the breech face impression into donut-shaped regions containing only breech face impression. Below is an example of such a toroidal region. Figure 3.54: (Left) The original breech face impression scan image. (Right) A donut-shaped region cut out of the original image. By comparing such regions instead of the square cells, we would presumably only need to fill in a few missing value “holes” in the breech face impression scan rather than completely replacing a non-existent signal with an artificial one. In the near-future, I hope to finish up the pre-processing needed for this Congruent Matching Tori method by performing a polar transformation on these images to make them into strips that can easily be compared via an FFT. Joe 9/12/19 Update: Explanation of some of the pre-processing steps needed to make the CMC work as described in Tong et al. (2015) Before carving out toroidal regions from the two images we wish to compare, a fair amount of pre-processing needs to be completed. For example, the scans we work with begin with a considerable amount of auxiliary information, for example the firing pin impression, that we don’t want to use in our comparisons. This isn’t to say that firing pin impressions aren’t useful to determine a match between two cartridge cases. In fact there is quite a lot of published research on how to compare two firing pin impressions. Rather, it is common practice to compare breech face impressions and firing pin impressions separately since it is difficult to scan both simultaneously. Thus, there are regions of a breech face impression scan that we want to remove so that the breech face impressions are more easily comparable. Below is an example of two breech face impression scans before processing. Figure 3.55: Two cartridge case scans before pre-processing. There are a variety of techniques to segment an image into various parts. In image processing, common techniques are the Canny edge detector, which identifies edges of shapes in an image using image gradient techniques, and the Hough Transform, which can detect a variety of geometrical shapes in an image. The Hough Transform is what is used to segment the cartridge case images used in the previous section. However, we’ve found that the use of a Hough Transform doesn’t extract the “breech face signal” from an image as other techniques. Namely, the breech face can be effectively extracted using the RANSAC (Random sample consensus) method that iteratively fits a plane to a set of data until it settles upon a consensus-based “bulk” of the data. In the case of these cartridge case scans, the bulk of the data should predominantely be distributed around the mode height value. That is, the breech face impression. Once we’ve fit this plane to the breech face impression, we can extract the residuals of the fit to better accentuate the markings left in the cartridge case base by a firearm’s breech face. Below is an example of the residuals left after fitting a RANSAC plane to two cartridge case scans above. In the example below, we grab any residuals less than 20 microns in magnitude. Figure 3.56: Residual values of a RANSAC plane fit to the two cartridge case scans shown above. Although these two images are of two different cartridge cases, you can hopefully see that one looks very much like a rotated version of the other. These two cartridge case scans are in fact fired from the same gun (known matches), so it’s a good thing that they look so similar. We’ve now removed quite a bit of the unwanted regions of the original scans. However, there are still some areas of the image (e.g., the faint circular region of pixels in the center of the breech face scan) that just so happened to be close to the fitted plane and thus were brought along in the residual extraction. There are a few ways that we can clean up these last few areas. One is to use two Hough Transforms to detect the inner and outer circles of the breech face impression and filter out any pixels outside of the region between these two circles. The biggest issue with using a Hough Transform is that it must be given the radius of the circle that it is to search for in the image as an argument. That is, we need to know the radius of the breech face impression that we haven’t yet identified in order to identify the breech face impression. Instead, we can dilate/erode (or vice-versa) the pixels in the image to remove the remaining “speckle” in the image. Below is an example of of the breech face impressions cleaned via a dilation/erosion procedure. Figure 3.57: The selected breech face impressions based on dilation and erosion. The final step in the pre-processing is to align the two images in some consistent fashion. Luckily, the firing pin impression ring that’s left after performing the above dilation/erosion provides us with some idea of how to align the breech face impressions. The location of the firing ring impression in the breech face impression provides us with an indicator of where the cartridge case was located relative to the firing pin when it was sitting in the barrel. So aligning two cartridge cases so that their firing pin impression rings align will ensure that, at the very least, the breech face impression left on the cartridge case is horizontally/vertically aligned if not rotationally aligned. Joe 9/18/19 Update: Continuation of pre-process explanation with a discussion on how we can automatically detect the firing pin impression radius in an image. To automatically detect the radius of a given breech face impression, we can count the number of non-NA pixels in each row. If we were to imagine scanning down an image and counting the number of non-NA pixels in each row, then this count would obviously start to increase the moment we hit the top of the breech face impression. Because the breech face impressions are circular, the count would continue to increase the further down the image we scan. That is, until we hit the firing pin impression circle. At this point, because the firing pin impression circle consists of NAs, we would expect the non-NA pixel count to dip. This increasing followed by decreasing behavior in the non-NA pixel count constitutes a local maximum. We can use this local maximum of the non-NA pixel count to identify the beginning of the firing pin impression circle. Similarly, we would expect the non-NA pixel count to reach another local maximum once we hit the end of the firing pin impression circle. It’s then a simple subtraction of the two row indices containing these local maxima to determine an estimate for the diameter of the firing pin impression circle. We can see below an example of the non-NA pixel row sums plotted against the row indices (starting from the top of the image and moving down). You can hopefully see that the raw row sums are rather “noisy”. As such, we can pass a moving average smoother over the row sum values so that the local maxima are easier to identify. This may not be the most robust way to determine the local maxima. I hope to investigate the use of b-splines fit over the row sum values to see if these would be more effective at finding local maxima Figure 3.58: Non-NA pixel row counts and moving average-smoothed row count values plotted against row index. However, because firing pin impression circles have somewhat perforated edges, performing one pass through the image may not yield a particularly accurate estimate. As such, we can repeat the process of finding the distance between local maxima for both the row and column non-NA pixel counts. We can also rotate the image by a few degrees and perform the same process. I am currently rotating the image 0, 15, 30, 45, 60, and 75 degrees and calculating row and column diameter estimates per rotation. Obviously we can apply whatever aggregation function we desire to these estimates to determine a final estimate. Below we see what the Hough Transform selects as the breech face for 4 different radii values. In particular, for circles of radius 210, 213, 216, and 219. Figure 3.59: Hough Transform selected circles (red) of radius (1) 210, (2) 213, (3) 216, and (4) 219. Joe 9/25/18 Update: Dilation and erosion of the breech face impression image seems to be fairly effective, but require some parameter tuning based on the firing pin impression we’re considering (e.g., effective erosion in one image may have a different, adverse effect in another image). The watershed algorithm appears to be a promising alternative to selecting the breech face impression out of an image containing extra “minutiae”. When trying to select the breech face impression out of an image such as the one below (this is a slice of the original scan based on the RANSAC method-selected breech face impression z-value), we’re really just interesting in obtaining a yes/no answer for each pixel to the question: “Are you a part of the breech face impression?” As such, rather than looking at the considering the raw pixel values, we can binarize the image to a 1/0 (equivalently, non-NA/NA) pixel representation. Such a representation is below. Figure 3.60: (Left) Residual values of a RANSAC plane fit to a cartridge case scan. (Right) Binarized non-NA/NA image for segmentation. Using this “indicator image”, the beginning/end of the breech face impression should be much more obvious to, say, a Canny edge detector. Below is the output of such a Canny edge detector. Figure 3.61: The edges of the binarized image above via a Canny edge detector. From here, we can use a Watershed image segmentation procedure to identify various regions within this image. The Watershed algorithm needs to be given a set of pixel locations that the user believes to be within distinct regions of the image. With these “seed” pixels, the algorithm then searches neighboring pixels and attempts to identify them as within/without the same region. Almost as if a water source turned on at the given seed pixel and water began to spread to as many neighboring pixels as it could. The water should “stop” at the black lines in the image above, thus defining the boundary of a seed pixel’s region. An example of the above image post-segmentation is given below. The 5 seed pixels I used were the 4 corners and center of the image. As we can, the watershed algorithm “overflowed” into the breech face impression, but segmented the firing pin impression circle from the rest of the image. Because most of the minutiae that we want to remove is in within this firing pin impression circle, this is not a problem for our purposes. With 5 seed images, there are technically 5 segments represented in the image below (although it’s hard to see where the outer segments begin/end). So as shown below, we can just binarize the segments as being a part of the firing pin impression circle or not. Figure 3.62: (Left) Watershed segmentation of the Canny edge image above. (Right) The firing pin impression circle binarization of the Watershed segmentation image. Finally, now that we’ve identified where the firing pin impression circle is in the original image, we can simply replace any pixel values within this circle with NAs. The final filtered image is shown below. Figure 3.63: Final filtered image. Joe 10/3/18 Update: Determined a fairly computationally intensive yet (seemingly) effective way to find the firing pin impression circle in an image using a grid search of possible radius values. I will now start putting together a package for easy access. I’m not yet sure what to call the package, so any ideas are welcomed We can find a rough estimate for the firing pin radius estimate using a variety of methods. The one that I’ve found to be fairly consistent in the few examples I’ve worked with (detailed in the in the 9/18/19 update) is by counting the number of non-NA pixels in each row/column of the image and identifying the distance between the two largest local maxima in this non-NA count sequence. We can pass a grid of radius values centered on this estimate to a Hough Transform and determine which radius picks out the firing pin impression circle most effectively. The difficulty is in how we quantify “effective” using the output of the Hough Transform. Below you can see the original image including the “minutiae” within the firing pin impression circle that we hope to filter out. You can also see the result of filtering out the firing pin impression circle based on the original radius estimate (210 pixels) obtained from the “local maxima” method. Figure 3.64: (Left) Original breech face impression image. (Right) The breech face impression image after filtering based on a Hough Transform-selected circle of radius 210 pixels. As already discussed, we can test a variety of radius values around the 210 estimate to determine which is best. Below is a gif animating the result of filtering based on a Hough Transform for radius values ranging from 190 to 230. Although a radius of 210 does a decent job of filtering out the minutiae, a slightly smaller radius may be preferred as larger circles tend to cut into the breech face impression. We obviously want to retain as much of the breech face impression as possible for our later analysis. Figure 3.65: Gif showing the result of filtering based on Hough Transform circles of various radii. Using the output of the Hough Transform-selected circles shown above we would like to determine an optimal radius with which to filter out the firing pin impression circle. I explored a few ways of quantifying how “effective” a given radius is at filtering out the firing pin impression minutiae while simulataneously retaining as much of the breech face impression surface as possible. For example, it seemed logical to me to count the number of non-NA pixels we would be throwing out if we filtered based on a particular radius value. As you can see from the gif above, larger radii end up chewing into the breech face impression surface while smaller radii appear to sort of bounce around inside of the firing pin impression circle. We may be able to look at the count of filtered non-NA pixel values for each radius and determine a threshold in which the circles become large enough to start chewing into the breech face impression. Unfortunately, that is not the case. You can see from the plot below on the left that the number of filtered non-NA pixels increased fairly steadily. There isn’t an obvious location along the curve signalling when the circles are getting to be too large (the differences between successive counts are also shown). Since that metric didn’t end up being fruitful, I had to explore alternatives. One alternative that isn’t obvious from just visualizing which pixels are filtered by each radius is called the “Hough score” which essentially quantifies how confident the Hough Transform is that it indeed found the circle that it was told to find in the image. The plot on the right below shows the top Hough scores for each radius value. We can see that there is some variability depending on the radius value. However, there are a range of radius values starting at 210 in which the Hough Transform is consistently rather confident in its circle detection. In fact, we can see from the gif above that radius values between 201 and 206 indeed do a good job of filtering out the firing pin impression circle. Currently, I am basing my final firing pin radius estimate on the radius value in the middle of the longest-running sequence of high-confidence radius values. In both example breech face impressions that I’ve been working with (same type, fired from the same firearm), this final estimate ended up being 203. This is obviously promising, but I would like to spend time to verify that my current method is generalizable to other cartridge case scans. Figure 3.66: (Left) The number of non-NA pixels filtered out by the Hough Transform-selected circles for different radius values. (Right) The Hough score curve used to determine the firing pin radius estimate. Joe 10/10/18 Update: Discuss how the algorithm generalizes to different pairs of cartridge cases. Based on a sample of 5 known-match pairs, it appears that the algorithm does do a good job of deciding on a rotation value to make one breech face impression match up well with the other. Now that the skeleton of the algorithm has, for the most part, been fleshed-out, we can finally start testing it on different pairs of breech face impressions. For the sake of an example, I have 5 known-match breech face impressions shown below. In the state shown, the scans have been pre-processed to the point that we can visualy see when a pair matches. Hopefully, the scans should look to you as if one is just a rotated version of the other. One iteration of the CMC algorithm was already discussed in-detail in the 9/5/19 Update above, so I won’t go into detail about that here (I’m saving it for my Spotlight in November). Instead, we can see a gif that shows which cells from image A and image B we compare when calculating the cross-correlation. Recall that the image A cells are 100x100 and image B cells are 200x200, which is why the cells on the right appear to cover more of the breech face impression than the cells on the left. Figure 3.67: (Left) 100x100 cells from Image A. (Right) 200x200 cells from Image B. As we can clearly see from the 5 pairs above, we need to perform rotations to properly align one with the other. We perform the cross-correlation calculation for 43 different rotation angles (of image B) to determine which rotation angle yields the highest correlation (\\(\\theta \\in [-179.5,180]\\) by \\(2.5^\\circ\\)). However, because we have broken up our images into cells, each cell in image A gets to “vote” for the theta value for which it had the highest correlation with its paired cell in image B. Below, we see the distribution of such theta values (referred to as the “registration angle” in Tong et al. (2015)). The histogram shows that the many of the cells tend to vote for theta values in a relatively small range, which bodes well for us in determining the optimal rotation angle. Figure 3.68: Histogram of the registration angle of highest correlation for each of the 5 pairs of breech face impressions. Since we clearly have a region of popular theta values for each pair, we can perform a finer search around these theta values to arrive at a more precise estimate. The histogram for this finer grid search is shown below. According to Tong et al. (2015), the minimum number of cells that must agree upon a theta value (up to some margin) for two breech face impressions to be called a “match” is 6. We can clearly see from the histogram below that this criterion is met. There are other criteria that Tong et al. discuss including how far we need to shift each cell in image A to achieve the highest correlation with the neighboring cell in image B. Those criteria also seem to be met on the examples I’ve looked at. Figure 3.69: A finer grid search histogram of the registration angle of highest correlation for each of the 5 pairs of breech face impressions. Finally, we can pick the most popular rotation angle for each firearm pair and visually compare how well the two breech face impressions match up. This is done so below. We can see that the algorithm has indeed selected good rotation values for each pair. Joe 10/17/18 Update: Continued testing the CMC algorithm on more known match and known non-match pairs of cartridge cases. It’s a time intensive process, but the current results show that the algorithm works for the majority of known match pairs and, most importantly, appear to be qualitatively similar to what is reported in Tong et al. (2015). I’ve continued to run the algorithm on a number of known match pairs of cartridge cases. Although the algorithm seems to work well for the majority of known match pairs, it isn’t perfect at picking the correct rotation angle. I haven’t yet determined the cause of when the algorithm fails to pick the correct rotation angle. Figure 3.70: A pair of known match cartridge cases that start off as rotationally mis-aligned. Figure 3.71: The same pair as above after being correctly aligned via the CMC algorithm. Below is an example of a pair for which the algorithm does a poor job of choosing the correct rotation to align the two images. Figure 3.72: A pair of known match cartridge cases that start off as rotationally mis-aligned. Figure 3.73: The same pair as above after being incorrectly aligned via the CMC algorithm. While running code, I’ve also been working on putting all of my working functions into a package. I should hopefully have something resembling a structured package by my spotlight in November. Joe 10/31/18 Update: Finished computing (almost) all 780 possible known match and known non-match comparisons for the 40 cartridge case scans discussed in the Tong paper. We’re running into an issue where the correlations we’re getting out appear to be signficantly lower than what we expect them to be based on the results reported by Tong et al. The biggest challenge is that we effectively need to guess how the images in the Tong paper were pre-processed, so certain decisions we make may drastically affect the final results. We’re going to see if making a few minor changes to the way we pre-process the images will change the results to what we expect. Our current goal is to demonstrate that the current form of the package produces “qualitatively similar” results to those presented by Tong et al. Unfortunately, we don’t actually know which data they used to produce their results. We have a strong suspicion that they just used the first pair of cartridge cases encountered when downloading the study’s data from the NBTRD website, so we’re going to try to base our results comparison based on those. Below we can see the known match cartridge case pair in their raw format before pre-processing. In this state, it’s difficult to make any comparisons between the two breech faces. The first step is to process these images to both remove as much of the non-breech face region of the image as possible and accentuate the breech face impression markings left on the cartridge case. We can see the results of the pre-processing below. It will hopefully look to you as if one of the images is simply a rotated copy of the other. Our goal is to automatically detect what the correct rotation value is to properly align the two images. In order to find the correct rotational value to align the two images, we divide the first image (fadul1-1) into a 7x7 grid of cells. For each cell in image 1, we select a similarly located, wider region in image 2 and calculate the cross-correlation between the image 1 cell and the larger image 2 region. Below is an image that illustrates this for a particular cell. Below is a gif showing an example of cell/region pairs for which the CCF is computed. Figure 3.74: (Left) 100x100 cells from Image 1. (Right) 200x200 cells from Image 2. Once we calculate the CCF for each cell/region pair, we rotate image 2 by a few degrees, say 3 degrees, and repeat the process. We can obviously keep track of the correlation values for each rotation and determine for which rotation values a particular image 1 cell attains its maximum CCF. If two cartridge cases are genuine matches, then we would expect there to be some consensus among the cells for which theta value they attain their max CCF. For example, below we see a histogram of theta values for which the cells in the fadul1-1 attain highest correlation in their associated fadul1-2 regions. We can see a peak around -20 degrees. In particular, the consensus-based theta value turns out to be -21 degrees. If we then consider the CCF values at the -21 degree rotation comparison, we see there are quite a few cells that could be classified as “highly correlated”. Tong et al. discuss various criteria they use to define a cell as a “Congruent Matching Cell.” For example, they set a minimum CCF value of .25. Based on the criteria that they set, we can see in the table below that there are 14 cells that can be defined as CMCs. In their original paper, the number of CMCs they found was 15. The discrepancy likely comes from the fact that they perform different pre-processing steps than we do but don’t discuss what those pre-processing steps are. cell_ID corr dx dy x = 1 - 82,y = 407 - 487 0.4605801 -7 -19 x = 83 - 163,y = 83 - 163 0.3465763 -1 -13 x = 83 - 163,y = 488 - 568 0.2773731 -35 25 x = 164 - 244,y = 488 - 568 0.3917978 -24 2 x = 245 - 326,y = 488 - 568 0.4946205 -17 1 x = 327 - 407,y = 407 - 487 0.4824218 4 2 x = 327 - 407,y = 488 - 568 0.4830941 -17 4 x = 408 - 488,y = 83 - 163 0.4034100 9 -13 x = 408 - 488,y = 164 - 244 0.3274178 4 -14 x = 408 - 488,y = 407 - 487 0.4588278 7 -3 x = 489 - 569,y = 83 - 163 0.5382969 9 7 x = 489 - 569,y = 164 - 244 0.4523592 -31 21 x = 489 - 569,y = 326 - 406 0.5687978 8 16 x = 489 - 569,y = 407 - 487 0.5720020 2 24 We can visualize which cells in fadul1-1 are classified as CMCs. The image below shows the fadul1-1 CMCs as well as fadul1-2 rotated by -21 degrees (the consensus-based theta value chosen from before). We can see that most of the regions with the most obvious visual similarity between the two cartridge cases (in particular, the linear markings in the bottom-right of each image) are indeed classified as CMCs. 3.3.3 Modified Chumbley non-random test 3.3.3.1 Land-to-land scores The moified Chumbley non-random algorithm is a statistical non-paramaetric test that compares two signatures under consideration and gives a test statistic. The test statistic is used to make classifications and compute error rates based on different nominal type I levels. The basic principle behind the method is to first take two marking that have to be compared, choose a segment length which is a portion of the signature, and use this window segement to find which windows give the maximum correlation. The lag between these respective markings is computed based on the location of the two maximum correlation windows in the two markings. Now the algorithm works in two steps where first, lag congruent correlations between several smaller windows of the two markings are computed, this is called the same-shift. The second step serves the purpose of computing windows of correlation between the two signatures with window sized the same as the same-shift, but the with the purpose of finding correlations when the windows are not lag synchronized. The second step is called different shift step and has a specific order in which the pair of windows are chosen between which the correlations are to be computed. The different-shift serves as benchmark for comparison. It shows a set of bad correlations, against which the same-shift correlations are compared. A U-statistic is computed for the comparison based on the correlations in this procedure. The modified chumbley method (Krishnan and Hofmann 2019) can work with two markings at a time. Therefore the method can be used for comparing signatures from one land to signature from another land. The land-to-land comparison was performed for Hamby 44 dataset from (Zheng 2016) and CSAFE (Krishnan and Hofmann 2019) and associated error rates were computed for these comparisons. 3.3.3.2 Bullet-to-bullet scores In this method we extend the modified chumbley non-random method from land-to-land scoring to bullet-to-bullet scoring. In order to do this, first 6 ordered pairs of lands between the two bullets are chosen for comparison. The modified chumbley method is used on these 6 pairwise comparisons. This results in the same-shift and different-shift comparisons from each of the 6 comparisons. We do not need a land-to-land pairwise U-statistics and classification in this method. Instead all the same-shift and different-shift correlations are now aggregated from the 6 comparisons and a new non-parametric U test is used on the aggregated sets. This gives a test statistic at the bullet level and consequently we can compute p-values. This is used with different nominal significance levels to identify bullet level error rates. 3.4 Analysis of Results 3.5 Communication of Results and Methods The results are communicated through an interactive user interface. The first part of this interface lets you add all the bullets, barrels and lands for which the random forest and other scores are to be computed. A preliminary diagnostic of the orientations and dimensions of the lands tell us, if we can proceed safely to extraction of markings and then to cross-comparisons. After this step, we can apply any sampling or interpolation needed on the land images, all these operations can be batched to the entire set of comparisons under consideration. Then we can make transformations like rotation, transpose etc on a sample image, visualize the results, and since we are dealing with conforming orientation and dimensions of lands present in the entire set, we can batch the transformations. We extract markings, locate grooves, align signatures, and generate cross-comparison results. Each step is notified in UI and all steps are logged. The scores and results are then communicated through an interactive visualization. We first interact at the top most level where we have bullet-to-bullet scores for all the cross-comparisons presented in a grid. We can select one comparison at a time which would generate a second level of grid visualization that shows the land-to-land scores for all 36 comparisons within a bullet. Interacting with this visualization, we can now pull up score tables, profiles, location of grooves, aligned signatures and raw images. The framework of interactions, allows for validation of classification recommended by the RF model as well as gives an opportunity to critically asses, identify the cause and diagnose any problems encountered in the bullet matching pipeline. Figure 3.75: An instance of the interactive visualizations for communicating results 3.5.1 Conference Presentations 3.5.1.1 American Academy of Forensic Sciences “Validation Study on Automated Groove Detection Methods in 3D Bullet Land Scans” February 2019 Authors: Kiegan Rice, Ulrike Genschel, Heike Hofmann Presentation given by Kiegan Rice 3.5.1.2 Association of Firearms and Toolmark Examiners Annual Training Seminar Heike’s talk “Reproducibility of Automated Bullet Matching Scores Using High-Resolution 3D LEA Scans” May 2019 Authors: Kiegan Rice, Ulrike Genschel, Heike Hofmann Presentation given by Kiegan Rice 3.5.1.3 Joint Statistical Meetings “A non-parametric test for matching bullet striations: extending the chumbley score for bullet-to-bullet matching” July 2019 Authors:Ganesh Krishnan, Heike Hofmann Talk given by Ganesh Krishnan “Repeatability and reproducibility of automated bullet comparisons using high-resolution 3D scans” July 2019 Authors: Kiegan Rice, Ulrike Genschel, Heike Hofmann Poster presented by Kiegan Rice 3.5.1.4 Miscellaneous 10th International Workshop on Statistics and Simulation in Salzburg, Austria, September 2019 “Reproducibility of High-Resolution 3D Bullet Scans and Automated Bullet Matching Scores” Authors: Kiegan Rice, Ulrike Genschel, Heike Hofmann Poster presented by Kiegan Rice, won 2nd Springer Poster Award “Case Study Validations of Automatic Bullet Matching” Authors: Heike Hofmann, Susan VanderPlas Presentation given by Alicia Carriquiry 3.6 People involved 3.6.1 Faculty Heike Hofmann Susan VanderPlas 3.6.2 Graduate Students Ganesh Krishnan Kiegan Rice Nate Garton Charlotte Roiger Joe Zemmels Yawei Ge 3.6.3 Undergraduates Talen Fisher (fix3p) Andrew Maloney Mya Fisher, Allison Mark, Connor Hergenreter, Carley McConnell, Anyesha Ray (scanner) References "],
["project-g-handwriting-signatures.html", "Chapter 4 Project G: Handwriting (&amp; Signatures) 4.1 Data Collection 4.2 Computational Tools 4.3 Statistical Analysis 4.4 Communication of Results 4.5 People involved", " Chapter 4 Project G: Handwriting (&amp; Signatures) The handwriting project has four major focuses: data collection computational tools statistical analysis glyph clustering closed set modeling for writer identification communication of results 4.1 Data Collection We are conducting a large data collection study to gather handwriting samples from a variety of participants across the world (most in the Midwest). Each participant provides handwriting samples at three sessions. Session packets are prepared, mailed to participants, completed, and mailed back. Once recieved, we scan all surveys and writing samples. Scans are loaded, cropped, and saved using a Shiny app. The app also facilitates survey data entry, saving that participant data to lines in an excel spreadsheet. Data collection is underway with the most recent update (10/3): 88 complete through session #3 11 complete through session #2 12 complete through session #1 As of September 2019, Marc and Anyesha are the primary contacts for the study. An article for Data in Brief will be drafted this semester. Authors: Anyesha Rey, Amy Crawford, Alicia Carriquiry. 4.2 Computational Tools handwriter is a developmental R package hosted at https://github.com/CSAFE-ISU/handwriter. It is our major computational tool for the project. The package takes in scanned handwritten documents and the following are performed. Binarize. Turn the image to pure black and white. Skeletonize. Reduce writing to a 1 pixel wide skeleton. Break. Connected writing is decomposed into small manageable pieces called glyphs . Glyphs are graphical structures with nodes and edges that often, but not always, correspond to Roman letters, and are the smallest unit of observation we consider for statistcal modelling. Measure. A variety of measurements are taken on each glyph. Figure 4.1: Connected text processed by handwriter. The grey background is the original pen stroke. Colored lines represent the single pixel skeleton with color changes marking glyph decomposition. Red dots mark endpoints and intersections of each glyph. For an input document, functions in the package give back a list of glyphs with path and node location information, adjacency grouping assignment, slope (pictured below), and centroid locations, among other things. Figure 4.2: A visual of the ``slope’’ calculation for two glyphs. We are currently working to incorporate the cluster grouping assignments into the package. This will be complete pending creation of a template. Code is running on the csafe-01 server for template creation. 4.3 Statistical Analysis 4.3.1 Clustering Paper submitted (September 2019)! Rather than impose rigid grouping rules (the previously used ‘’adjacency grouping’’) we consider a more robust, dynamic \\(K-\\)means type clustering method that is focused on major glyph structural components. Clustering algorithms require: A distance measure. For us, a way to measure the discrepancy between glyphs. A measure of center. A glyph-like structure that is the exemplar representation of a group of glyphs. Glyph Distance Measure We begin by defining edge to edge distances. Edge to edge distances are subsequently combined for an overall glyph to glyph distance. Edge to edge distances: Consider the following single edge glyphs, \\(e_1\\) and \\(e_2\\). Make \\(3\\) edits to \\(e_1\\) to match \\(e_2\\). The combined magnitude of each edit make the edge distance. Figure 4.3: Two edges that are also glyphs, \\(e_1\\) and \\(e_2\\). Shift. Anchor to the nearest endpoint by shifting. Figure 4.4: Shift = 1.4. Stretch. Make the endpoints the same distance apart. Figure 4.5: Stretch = 9.9. Shape. Bend and twist the edge using \\(7\\) shape points. Shape points are ‘’matched’’ and the distance between them is averaged to obtain the shape contribution to the distance measure. Figure 4.6: Shape Components. Figure 4.7: Shape = 8.4. Combine the three measurements for a final edge to edge distance. D\\((e_1, e_2) = 1.4 + 9.9 + 8.4 = 19.7\\). For multi-edge glyphs get pairwise edge distances. Minimize total glyph distance using linear programming to match edges (sudoku). Down-weight edge distance contributions based on edge lengths. There are nuances associated with all of this. We must handle glyphs with differing number of edges, and consider the direction in which edges are compared (endpoint labels are arbitrary). All of this is addressed in detail in the paper. Measure of glyph centers Take the weighted average of endpoints, \\(7\\) shape points, and edge length. Figure 4.8: Weighted mean between two glyphs. p = weight on blue. The mean of a set can be iteratively calculated by properly weighting each newly introduced glyph. For stability, the \\(K-\\)means algorithm finds the glyph nearest the mean and uses that as measure of cluster center. \\(K-\\)means Algorithm for Glyphs Implement a standard \\(K-\\)means12 with handling of outlier observations.3 Begin with fixed \\(K\\) and a set of exemplars. Iterate between the following steps until cluster assignments do not change: Assign each glyph to the exemplar it is nearest to, with respect to the glyph distance measure. Calculate each cluster mean as defined. Find the exemplar nearest the cluster mean and use it as the new cluster center. Figure 4.9: One of \\(K=40\\) Clusters. Exemplar &amp; cluster members (left). Cluster mean (right). Use one document from each training writer to cluster and obtain a template. Make cluster assignments for the remaining documents by finding the template exemplar each glyph is nearest to. Below is an example of data that arises from the clustering method. Figure 4.10: Data arising from the cluster grouping method. Cluster #’s ordered by most to least populated. 4.3.1.1 Outliers During clustering, outliers are considered glyphs that are at least \\(T_o\\) distance units from cluster exemplars. The algorithm sets a ceiling \\(n_o\\) on the allowable number of outliers. Initially, we were going to ignore the outliers, but now they are considered the \\(K+1\\)th cluster and contribute information about writer. Figure 4.11: Cluster of outliers. 4.3.2 Closed set modeling Model #1, Straw Man Let, \\(\\boldsymbol{Y}_{w(d)} = \\{Y_{w(d),1}, \\dots, Y_{w(d),K}\\}\\) be the number of glyphs assigned to each cluster for document within writer, \\(w(d),\\) and \\(\\boldsymbol{\\pi}_w = \\{\\pi_{w,1}, \\dots, \\pi_{w,K} \\}\\) be the rate at which a writer emits glyphs to each cluster. Here, \\(K = 41\\), \\(d = 1,2,...,5\\), \\(w = 1,...,27\\). Then a hierarchical model for the data is \\[\\begin{array}{rl} \\mathbf{Y}_{w(d)}\\: &amp;\\stackrel{ind}{\\sim} \\:Multinomial(\\boldsymbol\\pi_{w}), \\\\ \\boldsymbol{\\pi}_w \\:&amp;\\stackrel{ind}{\\sim}\\: Dirichlet(\\boldsymbol{\\alpha}),\\\\ \\alpha_{1}, \\dots, \\alpha_{K}\\: &amp;\\stackrel{iid}{\\sim}\\: Gamma(2, \\:0.25). \\label{model_line3} \\end{array}\\] Posterior Predictive Analysis For a holdout document of unknown source, \\(w^*\\), Extract glyphs with and assign groups, \\(\\boldsymbol{Y}^*_{w^*}=\\{Y_{w^*,1}, ... Y_{w^*,K}\\}\\) Assess the posterior probability of writership under each known writer \\(\\boldsymbol\\pi_{w}\\) vectors. i.e. \\(p(w^* = w^\\prime|\\boldsymbol{Y^*}, \\boldsymbol{Y})\\) for each writer \\(w^\\prime\\) in the training data. The posterior probability that the questioned document \\(\\boldsymbol{Y}^*_{w^*}\\) belongs to writer \\(w^\\prime\\) with respect to the closed set is, \\[\\begin{array}{rl} p(w^* = w^\\prime|\\boldsymbol{Y}^*, \\boldsymbol{Y}) &amp; \\propto p(\\boldsymbol{Y}^*| w^* = w^\\prime, \\boldsymbol{Y}) p(w^*=w^\\prime | \\boldsymbol{Y})\\nonumber\\\\ &amp; \\propto p(\\boldsymbol{Y}^*| w^* = w^\\prime, \\boldsymbol{Y}) \\nonumber\\\\ &amp; = \\int p(\\boldsymbol{Y}^*| \\boldsymbol{\\pi}_{w^\\prime}) p(\\boldsymbol{\\pi}_{w^\\prime}| \\boldsymbol{Y}) d \\boldsymbol{\\pi}_{w^\\prime}\\nonumber\\\\ &amp; \\approx \\frac{1}{M} \\sum_{m=1}^M p(\\boldsymbol{Y}^*| \\boldsymbol{\\pi}^{(m)}_{w^\\prime}) , \\mbox{ where } \\boldsymbol{\\pi}^{(m)}_{w^\\prime} \\sim p(\\boldsymbol{\\pi}_{w^\\prime}|\\boldsymbol{Y}) \\nonumber \\end{array}\\] for MCMC iterations \\(m = 1, \\dots, M\\). Then, for a given iteration \\(m\\), \\[ p(\\boldsymbol{Y}^*| \\boldsymbol{\\pi}^{(m)}_{w^\\prime}) = p_{w^\\prime}^{(m)} = \\frac{Mult(\\boldsymbol{Y}^*; \\boldsymbol{\\pi}_{w^\\prime}^{(m)})}{\\sum_{w_i = 1}^{27}Mult(\\boldsymbol{Y}^*; \\boldsymbol{\\pi}_{w_i}^{(m)}) }. \\nonumber \\] Calculate the quantitity for each known writer \\(w^\\prime = w_1, \\dots, w_{27}\\) in training set to get \\[ \\boldsymbol{p}^{(m)} = \\{p_{w_1}^{(m)}, ..., p_{w_{27}}^{(m)}\\}, \\] and compute summaries over the MCMC draws, \\[ \\boldsymbol{\\bar{p}} = \\{\\bar{p}_{w_1},...,\\bar{p}_{w_{27}}\\}. \\] Results If we use a single holdout document for each writer (doc 4). The \\(\\boldsymbol{\\bar{p}}\\) vector as given above is shown graphically for each holdout document (the rows). Figure 4.12: Posterior predictive results. Rows are evaluated independently and the probability in each row sums to one. Log Loss = 0.2013 We can use a cross validation routine to estimate error. For each writer, shuffle the order of their body of documents. For the first fold we holdout the first document for testing, for the second fold we hold out the second document for testing, etc.. This yields 6 results analogous to that of the figure above. Figure 4.13: Posterior predictive results for each fold of the CV routine outlined above. Log Loss is clearly not a great summary of performance. Evaluating Over-/Under-dispersion (Writer Variability Index) With a count data model it is important to investigate the presence of over- and under-dispersion. An index of intra-writer variability with respect to a model. Multivariate Generalized Dispersion Index (GDI) of Kokonendji and Puig4. Relative Dispersion Index (RDI) = \\(\\frac{\\mbox{writer data GDI}}{\\mbox{model simulated GDI}}.\\) High RDI \\(\\implies\\) data over-dispersion and high sample to sample variability. Figure 4.14: RDIs for the 27 CVL writers under Model #1. High RDI \\(\\implies\\) data over-dispersion &amp; high sample to sample variability (in the sense of glyph cluster membership rates). Figure 4.15: Handwriting Samples from Writer #12. Notice the repeated patterns in letters ‘a’, ‘e’, ‘f’, ‘g’, ‘h’, ‘t’, etc. across samples. Figure 4.16: Handwriting Samples from Writer #23. Note the red ’h’s, green ’ll’s, purple terminal ’y’s, and blue ’loo’s Model #2, Mixture There seem to be greatly varying shapes in the relative frequency of cluster fill. We think maybe a more flexible Dirichlet distribution is warranted. Figure 4.17: Average relative frequency of cluster fill for the 8 most common clusters. Notice writers 12/21 and 6/17/18. Add flexibility to the original model by including a mixture component in the Dirichlet parameter space. \\[\\begin{array}{rl} \\mathbf{Y}_{w(d)} | \\boldsymbol\\pi_{w}, w\\: &amp;\\stackrel{ind}{\\sim} \\:Multinomial(\\boldsymbol\\pi_{w}), \\\\ \\boldsymbol{\\pi}_w|\\boldsymbol{\\alpha},\\boldsymbol{\\beta}, \\rho_w \\:&amp;\\stackrel{ind}{\\sim}\\:Dirichlet(\\rho_w \\: \\boldsymbol{\\alpha}+ (1-\\rho_w) \\: \\boldsymbol{\\beta}), \\\\ \\alpha_{k}, \\: \\beta_{k} \\: &amp;\\stackrel{iid}{\\sim}\\: Gamma(2, \\: 0.25) \\:\\: \\mbox{ for } k &gt; 3, \\\\ \\rho_w\\: &amp; \\stackrel{iid}{\\sim}\\: Beta(1,1) \\end{array}\\] Label Switchin Issues. The model is non-identifiabile. We need to either place constraints on the parameter space to exclude the possibility of a second mode apriori, or estimate the posterior in both modes and post-process for label reassignment after. This has been resolved (?) by placing constraints on the first three elements of \\(\\alpha\\) and \\(\\beta\\) with moderately informative priors. \\(\\mathbf{\\alpha_1 &lt; \\beta_1}\\), \\(\\quad\\) \\(\\alpha_1 \\sim Gamma(2, 0.25) \\:\\: \\&amp; \\:\\: \\beta_1 \\sim Gamma(4, 0.25)\\) \\(\\mathbf{\\alpha_2 &gt; \\beta_2}\\) , \\(\\quad\\) \\(\\alpha_2 \\sim Gamma(4, 0.25) \\:\\: \\&amp; \\:\\: \\beta_2 \\sim Gamma(1, 0.25)\\) \\(\\mathbf{\\alpha_3 &gt; \\beta_3}\\) , \\(\\quad\\) \\(\\alpha_3 \\sim Gamma(4, 0.25) \\:\\: \\&amp; \\:\\: \\beta_3 \\sim Gamma(1, 0.25)\\) Results The mixing component gives insights into writing style. Figure 4.18: Average $ ho_w $ value for each writer. Figure 4.19: Writing samples in a variety of styles based on the mixing parameter. From top to bottom, writer #’s 21, 4, 29, 20, 18. Evaluate the posterior probability of writership for each of the holdout documents. Figure 4.20: Posterior predictive results. Rows are evaluated independently and the probability in each row sums to one. Log Loss = 0.2078 Model #3, Normal Slopes. Work in progress. Adding slope measurements into the model. Let, \\(\\boldsymbol{Y}_{w(d)} = \\{Y_{w(d),1}, \\dots, Y_{w(d),K}\\}\\) be the number of glyphs assigned to each group for document within writer, \\(w(d),\\) \\(\\boldsymbol{\\bar{S}}_{w(d)} = \\{\\bar{S}_{w(d),1}, \\dots, \\bar{S}_{w(d),K}\\}\\), be the average slope in each group for document \\(w(d)\\) \\(G_{w(d),j}\\) be the \\(j^{th}\\) glyph in document \\(w(d)\\), \\(g_{w(d), j} = 1, \\dots, 41\\) be the available cluster assignments for the \\(j^{th}\\) glyph in the document, \\(S_{w(d),j}\\) be the slope of the \\(j^{th}\\) glyph in the document. Here, \\(K = 41\\), \\(d = 1,2,...,5\\), \\(w = 1,...,27\\), \\(j= 1, \\dots,\\mathrm{J}_{w(d)}.\\) \\[ \\bar{S}_{w(d),k}= \\frac{1}{Y_{w(d),k}} \\sum_{j \\ni \\mathrm{I}[g_j = k]}S_{w(d),j} \\quad \\&amp; \\quad Y_{w(d),k} = \\sum_{j = 1}^{\\mathrm{J}_{w(d)}} \\mathrm{I}[g_j = k] \\] Then a hierarchical model for the data is \\[\\begin{array}{rl} \\mathbf{Y}_{w(d)} | \\boldsymbol\\pi_{w}, w\\: &amp;\\stackrel{ind}{\\sim} \\:Multinomial(\\boldsymbol\\pi_{w}), \\\\ \\boldsymbol{\\pi}_w|\\boldsymbol{\\alpha} \\:&amp;\\stackrel{ind}{\\sim}\\:Dirichlet(\\boldsymbol{\\alpha}), \\\\ \\alpha_k\\: &amp;\\stackrel{iid}{\\sim}\\: Gamma(a = 2, \\: b= 0.25), \\\\ \\bar{S}_{w(d),k} | Y_{w(d),k}, w, \\mu_{w, k}, \\sigma^2_{k} \\: &amp; \\stackrel{iid}{\\sim}\\: N \\left(\\mu_{w, k}, \\frac{\\sigma^2_{k}}{Y_{w(d),k}}\\right) \\\\ \\mu_{w, k} | \\mu_{k} \\: &amp; \\stackrel{iid}{\\sim}\\: N(\\mu_{k}, 3) \\\\ \\mu_{k} \\: &amp; \\stackrel{iid}{\\sim}\\: N(0, 3) \\\\ 1/\\sigma^2_{k}\\: &amp; \\stackrel{iid}{\\sim}\\: Gamma(0.5, 0.1) \\end{array}\\] Consider a new document with cluster fill counts \\(\\boldsymbol{Y}^*\\) and average slope measurements \\(\\boldsymbol{\\bar{S}}^*\\) from unknown writer \\(w^*\\). Posterior Predictive Analysis Posterior probability that the questioned document belongs to writer \\(w^\\prime\\) with respect to the closed set is: \\begin{array}{rl} &amp;p(w^* = w|* ^, ) \\ &amp;p(^ | w^* = w^, ) \\ &amp; _{m=1}^{M} Mult(^*; _{w}{(m)}) \\end{array} for MCMC samples \\(m = 1, \\dots, M\\). Results Evaluate the posterior probability of writership for each of the holdout documents. Figure 4.21: Posterior predictive results. Rows are evaluated independently and the probability in each row sums to one. Log Loss = 0.0883. Modeling Summary Model Data LogLoss #1 Adjacency Grouping (not presented) 0.5413 #1 Cluster Grouping 0.2013 #2 Cluster Grouping 0.2078 #3 Cluster Grouping &amp; Glyph Slopes 0.0883 4.4 Communication of Results Presenting author is in bold. 4.4.1 Papers “A Clustering Method for Graphical Handwriting Components and Statistical Writership Analysis” Authors: Nick Berry and Amy Crawford Submitted to The Annals of Applied Statistics in September 2019. “Bayesian Hierarchical Modeling for Forensic Handwriting Analysis” Authors: Amy Crawford, Alicia Carriquiry, and Danica Ommen In preparation for submission to PNAS “A Database of Handwriting Samples for Applications in Forensic Statistics” Authors: Anyesha Rey, Amy Crawford, and Alicia Carriquiry In preparation for submission to Data in Brief 4.4.2 Talks “Statistical Analysis of Handwriting for Writer Identification” August 2019 Authors: Amy Crawford, Nick Berry, Alicia Carriquiry, Danica Ommen American Society of Questioned Document Examiners (ASQDE) Annual Meeting in Cary, NC. “A Bayesian Hierarchical Mixture Model with Applications in Forensic Handwriting Analysis” July 2019 Authors: Amy Crawford, Nick Berry, Alicia Carriquiry Danica Ommen Joint Statistical Meetings (JSM) in Denver, CO. “Forensic Analysis of Handwriting” July 2019 Authors: Alicia Carriquiry, Amy Crawford, Nick Berry, Danica Ommen VI Latin American Meeting on Bayesian Statistics (VI COBAL), Lima, Peru. “Exploratory Analysis of Handwriting Features: Investigating Numeric Measurements of Writing” February 2019 Authors: Amy Crawford, Nick Berry, Alicia Carriquiry, Danica Ommen American Academy of Forensic Sciences (AAFS) Annual Meeting in Baltimore, MD. “Toward a Statistical and Algorithmic Approach to Forensic Handwriting Comparison” August 2018 Authors: Amy Crawford and Alicia Carriquiry American Society of Questioned Document Examiners (ASQDE) Annual Meeting in Park City, UT. “A Bayesian Approach to Forensic Handwriting Evidence” July 2018 Authors: Amy Crawford and Alicia Carriquiry Joint Statistical Meetings (JSM) in Vancouver, BC, Canada. “Bringing Statistical Foundations to Forensic Handwriting Analysis” May 2018 Authors: Amy Crawford and Alicia Carriquiry American Bar Association, 9th Annual Prescription for Criminal Justice Forensics Program in New York, NY. 4.4.3 Posters “A Bayesian Hierarchical Model for Forensic Writer Identification” September 2019 Authors: Amy Crawford, Alicia Carriquiry, Danica Ommen 10th International Workshop on Statistics and Simulation in Salzburg, Austria 1st Springer Poster Award “Statistical Analysis of Handwriting” May 2019 Authors: Amy Crawford and Nick Berry CSAFE Annual All-Hands Meeting in Ames, IA “Statistical Analysis of Letter Importance for Document Examination” February 2018 Authors: Amy Crawford and Alicia Carriquiry American Academy of Forensic Sciences in Seattle, WA YFSF Best Poster Award (Presented AAFS 2018 Poster for a Second Time) May 2018 Authors: Amy Crawford and Alicia Carriquiry CSAFE Annual All-Hands Meeting in Ames, IA 4.5 People involved 4.5.1 Faculty Alicia Carriquiry Hal Stern (UCI, Project G PI) Danica Ommen 4.5.2 Graduate Students Amy Crawford 4.5.3 Undergraduates Anyesha Rey (data collection) James Taylor (feature extraction) Forgy, E. (1965). Cluster Analysis of Multivariate Data: Efficiency vs. Interpretability of Classifications. Biometrics, 21:768–780.↩ Lloyd, S. (1982). Least Squares Quantization in PCM. IEEE Trans. on Information Theory, 28(2):129–137.↩ Gan, G. and Ng, M. K.-P. (2017). K-means clustering with outlier removal. Pattern Recog. Letters, 90:8–14.↩ Kokonendji, C. C. and Puig, P. (2018). Fisher Dispersion Index for Multivariate Count Distributions. Journal of Multivariate Analysis, v165 p180-193.↩ "],
["glass-chemical-compositions.html", "Chapter 5 Glass: Chemical compositions", " Chapter 5 Glass: Chemical compositions Evaluation and comparison of methods for forensic glass source conclusions, Soyoung Park and Sam Tyner Get reviews back from Forensic Science International Most of comments from Reviewer1 are minor on format or forensic background Reviewer2 said I very much enjoyed reading your paper and congratulate you on a really nice piece of work What we plan to do, Revise the maunuscript as comments by reviewers ASAP Will get more data Write a paper describing data in Data in Brief "],
["shoes.html", "Chapter 6 Shoes 6.1 Longitudinal Shoe Study 6.2 Passive Shoe Recognition 6.3 Maximum Clique Matching 6.4 Project Tread (formerly Cocoa Powder Citizen Science) 6.5 3d Shoe Recognition 6.6 Shoe outsole matching using image descriptors 6.7 Impact of weight to outsole scans from EverOS 2D scanner", " Chapter 6 Shoes 6.1 Longitudinal Shoe Study Github repository 6.1.1 Paper describing the database Paper subdirectory of Github repository Goal: Describe experiment Describe database function Publicize data for analysis by others in the community Methods and Data Description Methods and data description handed off to Alicia for editing Data Analysis Tools Working with the EBImage package - very fast processing of images ShoeScrubR package Cleaning methods for the Longitudinal data are contained in the ShoeScrubR package. The package includes (as of 2019-10-17) a complete set of tests to guard against regressions (100% test coverage!) and uses continuous integration to ensure that the installation process is also monitored. The ShoeScrubR package also includes logging of all image-in image-out operations using attributes - each time a transformation is performed, the transformation and the parameters are appended to the running operations log. This should make it possible to track the provenance of an object through the set of transformations (and potentially un-do them in some cases). Film and Powder Images The images are challenging to do basic statistical analysis on because the shoe print is made up of tiny particles (e.g. it is not a solid object), and there are areas of smudged particles outside the image (fingerprints, etc.) that can be hard to automatically remove. In addition, the film backing has subtle variations in color. The prints are not rotationally aligned, that is, they are taken at a variety of angles (usually \\(\\pm 15^\\circ\\) from vertical) which vary due to individual differences in walking style, the orientation of the film, and changes in experimental protocol. Experimental protocol changes included resolution changes for the scans over time: the resolution of the last set of images is about 2 times higher than the resolution of the first 3 check-ins worth of images. Thus, parameters need to be automatically selected based on the resolution of the image. The initial use of templates to clean up the image requires addressing the alignment of the print and the template. As this experiment contains 8 total shoe model and size combinations, it is possible to create a template for each shoe model and use that template to isolate the region of the image which contains a set of features most likely to be a shoe (rather than random noise). Solving the template problem by aligning the mask and template yields an additional benefit: the resulting cleaned up image is roughly aligned relative to the template and, presumably, to other images. Rough Alignment of Template Mask and Image: Clean images, do a rough alignment between the image and the corresponding shoe mask (per model and size). Rotationally align image and mask using principal components on the non-background pixels in the image Gross align the non-background pixels in the image and mask Use a “mask-ified” version of the shoe print that encloses most of the shoe region in a single region (see below for explanation) Default to trimming the actual print by 5% on each dimension to minimize the effect of page borders and creases Alignment method options: center of mass - this fails if a print does not account for the whole shoe center of narrowest width - ideally, this is approximately the arch of the shoe. This works better than center of mass in most cases, but occasionally computation fails because it relies on finding a local minimum near the center of the image; if the derivative calculation fails, the algorithm falls back to the center of narrowest width. Pad the image and mask so that the centers are aligned and the image and mask are the same size Set any pixels outside the mask to background Before: After: These steps are wrapped into the rough_align function in the ShoeScrubR package. Cleaning the image and exaggerating into a mask In several of the methods applied to this data, it has been useful to have an exaggerated version of the image to function as a mask - this exaggerated image has a center of mass similar to the actual mask, for instance. Creating this mask requires parameter tuning (done the old way); a new method was developed in order to reduce the number of parameters which depended on image resolution and other similar items. In the old method, there were several parameters necessary - gaussian blur diameter for image cleaning, threshold for binarization, gaussian blur diameter for mask creation, threshold for image cleaning, diameter for opening the mask, diameter for closing the mask. The new steps are as follows: Use the EM algorithm to cluster the intensities of the points into three normally distributed categories: signal, intermediate, and background. The normality assumption is highly questionable, but the method works pretty well. Use the calculated pdf values for each point to construct a likelihood ratio of P(signal)/P(intermediate + background). Binarize based on the value of this likelihood ratio - if it’s over 10, the pixel is signal. Each shoe is shown in three separate images, corresponding to the pdf value for each point based on the EM algorithm clustering distribution fitted values. White pixels are highly likely to belong to the group in question - signal, intermediate, and noise. Binarized versions of each shoe The binarized image from the EM algorithm is cleaned slightly using parameters that should be robust to different ppi images (diameters &lt; 10 pixels) - this gets rid of speckling induced by the EM segmentation. Initial cleaning - dilation and erosion at very small pixel values Labeling disjoint regions (different colors indicate different regions) Removing any blobs which are in the 50px square corner region and which do not involve more than 10% of the image. At this point we can use the mask to clean the image: The binarized image is exaggerated using parameters which depend only on the size of the image. In general, size \\(s\\) here is the square root of the number of pixels in the image, that is, the side length of the image if it were square. A gaussian blur is applied to the image (diameter \\(s\\)/50) Any pixel intensity less than the median is determined to be shoe All disjoint regions are labeled The largest region is selected as the best mask for the shoe Some cleaning is done to this mask - any holes are filled in and then it is opened by a diameter of approximately \\(s\\)/5 (must be odd) At this point we can use the mask to get a “clean” image: And proceed with the alignment as normal: Aligning each image to the template corresponding to the shoe model and size provides a good first step towards aligning the images to one another, but additional work is necessary in order to ensure that we can compare two images from the same shoe (or two images from different shoes). Fine Alignment of two images using RNiftyReg The RNiftyReg package is intended for alignment of brain scans and other MRI data and uses a symmetric block-matching approach(Modat et al. 2014). It only allows for registration of images up to 2048x2048, though, which means we will have to align images at a lower resolution and then modify the transformation matrix accordingly. One definite positive feature is that it allows for provision of a mask for both the source and target images so that only pixels within the mask are used for alignment. Affine transformations are a type of image transformation that encompasses translation, resizing, rotation, and skew operations. Affine transformations preserve collinearity and ratios of distances: parallel lines remain parallel after the transformation. A subset of affine transformations are so-called “rigid body” transformations, which only allow translation and rotation. RNiftyReg allows for linear (rigid-body, affine), and nonlinear transformations, but for the moment, we are only interested in rigid-body transformations - while the shoes may have some slight distortion due to the wearer and kinematics of walking, this is minor and should not interfere too greatly with a gross alignment. RNiftyReg’s niftyreg.linear function returns a 4x4 transformation matrix describing the composition of multiple image transformation operations. A 3x3 matrix is necessary for 3-dimensional image rotation, resizing, and skew operations; it is then augmented by a row of zeros on the bottom and a column ending with a 1 that describes the x, y, and z translation coordinates. In this way, a 4x4 matrix can represent the composition of all relevant image transformation operations in 3 dimensions. In two dimensions, many of the cells in this matrix are 0. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Cells 1, 2, 5, 6 describe the rotation operation; the angle of rotation can be recovered using trigonometry. Cells 4, 8 describe the translation operation, e.g. the row (4) and column(8) offset from one matrix to another. For 2D rigid transformations, these are the only cells which matter. Cells 11 and 16 are 1, and 3, 7, 9, 10, 12, 13, 14, 15 are all 0 under these constraints. In order to use RNiftyReg for registration of the original-size images, we have to scale cells 4 and 8, but the rest of the cells remain unscaled. Note that EBImage uses what is essentially the transposed version of the matrix used by RNiftyReg, reduced to elements 1, 2, 5, 6, 4, 8 in a 3 row by 2 column matrix. 1 5 2 6 4 8 Starting with a set of 6 shoes observed at 3 timepoints each, with 2 different “modes” of print capture, we can align both prints taken on the same date for each shoe. The original images: (1 and 2 are taken at the same time point, 3 and 4, etc. 1-6 are the same physical shoe over time and so on) The images are first aligned to masks, which are used to clean the images to reduce noise. Then reduced-size versions of each image pair are aligned, producing a transformation matrix: 0.9999730 -0.0073485 0 30.48815 0.0073485 0.9999730 0 -10.16105 0.0000000 0.0000000 1 0.00000 0.0000000 0.0000000 0 1.00000 (this is one example) The coordinates in bold have been scaled according to the size reduction, so that they can be applied to the full-size images. The resulting aligned images are shown above; black pixels are areas where both images agree; pink and blue pixels represent areas found in one image but not the other. Some images which have many bubbles (air between the film and backing) or which contain blurred or double prints do not align accurately; this is really not avoidable with automatic alignment solutions. The alignment process itself (without any image preprocessing) is extremely fast, about 1s per image pair, and seems to be similar even when image size is increased by a factor of 16. Due to the scaling process and necessary modification of the transformation matrix, the alignments may be off by 1-5 pixels in some cases. This might be handled by aligning a smaller subset of the image at full resolution. Efforts to align sub-images produced less accurate alignments, likely due to the kinematic distortion of the sole during the walking process, resulting in situations where the local alignment estimate is not a good estimate of the global alignment. New attempts to find consensus alignment might include keypoint-based alignment methods, trying to identify the shoe border precisely to align that, and possibly use of Hough transforms to identify specific reproducible features that might serve as global keypoints. Given how well RNiftyReg works, the next question is whether all of the preprocessing is even necessary. In the image below, the first row is alignment with the full image, the second is alignment with a binarized version of the output image (so masked + thresholded), and the third is automatically cropped around the mask which is aligned to the image using the rough-align process. The third row maintains most of the information and produces better alignments than the other rows; thus, we can conclude that it’s necessary to combine the preprocessing and rough alignment in order to get the best results from RNiftyReg. Fine Alignment of two images using FFT Basic Process: Pad images so they’re the same size (Let’s say that \\(A\\) and \\(B\\) are the two images) Downweight the edges of the images using a Hann function This is necessary because Fourier transforms assume images go on forever, so abrupt changes (e.g. edges) don’t work out that well. Computationally, the image is “wrapped” around itself to be considered “infinite”. Use the Fast Fourier Transform on each image. Center the FFT’d images so that low frequencies are in the center (exchange top left quadrant with bottom right, and top right quadrant with bottom left). Call the FFT’d, centered images \\(F(A)\\) and \\(F(B)\\) Recover the angle between the two images: In Fourier space, a rotated image produces the same signal in Fourier space, but rotated. To recover this information, we can use the magnitude of the FFT’d images as a new image. Call these images \\(|F(A)|\\) and \\(|F(B)|\\). Then, Polar transform the image, so that a rotation of the original image is a linear shift of the transformed image (\\(P(|F(A)|)\\) and \\(P(|F(B)|)\\)). Apply Hann functions to the polar-transformed images. Use FFT-based alignment (see steps 3, 5) to pick out the \\(\\theta, \\rho\\) which best align the two polar images Discard \\(\\rho\\) and keep \\(\\theta\\). Transform the original image (not the FFT’d image) to get \\(\\tilde{B}_\\theta\\) and recompute the FFT on the rotated image (\\(F(\\tilde{B}_\\theta)\\)). Recover the shift between the two images: Compute the cross-power spectrum: \\(S = F(A) \\times F(\\tilde{B}_\\theta)*\\), where \\(F(x)*\\) is the complex conjugate of \\(F(x)\\) (e.g. \\(a + bi\\) becomes \\(a - bi\\)) Compute the magnitude of the cross-power spectrum: \\(|S| = \\sqrt{S \\times S*}\\) Use (a) and (b) to get the normalized cross power spectrum: \\(S/|S|\\) Take the inverse FFT of \\(S/|S|\\): \\(A = F^{-1}(S/|S|)\\) Find the maximum of the \\(A\\) matrix. The row and column where the maximum is found are the shift to align the two images: \\((\\Delta x, \\Delta y)\\). Apply the shift to image \\(\\tilde{B}_\\theta\\) to get \\(\\tilde{B}_{\\theta,\\Delta x, \\Delta y}\\). There are some fiddly details (e.g. converting shifts which are most of the image into negative shifts), but FFT-based alignment works pretty well (and pretty quickly) for shoes. Original Images: Angle-aligned Images: FFT-Aligned Result: (still working out the kinks) Combining information from multiple images With aligned images, we can then combine the information in each of the two prints taken at the same timepoint to get more reliable images. Because the methodology for acquiring the prints changed from timepoint to timepoint, the analysis of each type of print doesn’t make sense - it is completely conflated with the observation date. However, the multiple prints aren’t wasted, because while each print may be missing information, the combination of both of the prints (when properly aligned) provides a much more reliable assessment of the shoe (and the wear of that shoe at the proper timepoint). There are at least 3 options to combine these images (note that white = 1, black = 0): Take the pixel-by-pixel minimum: this keeps all the noise from both images (but there’s relatively little noise in the cropped images, so that may not matter too much). If images are misaligned, this results in a “double” print (or smeared print). This method is also sensitive to the lightness of the print - a complete print would still be ignored if the “dark” part of the print was lighter than the “light” part of the second print. Take the pixel-by-pixel maximum: this keeps only points which appear strongly in both images (losing a lot of data but also a lot of noise in the process) Take the pixel-by-pixel mean: This would result in lighter regions where one image has “gaps” but would reduce noise and make it clear where there is less sure information. Of these options, the first seems like the best, but the last provides some idea of whether the alignment was decent to begin with. The alignment method seems to fail more frequently when one of the images is very light. It may be advantageous to invest more effort into adaptive histogram normalization. Alignment Fails: Alignment Success: Wear Characterization Ideas: average intensity of cleaned image length of border/edges detected 6.2 Passive Shoe Recognition 6.2.1 NIJ Grant Grant scope: Build the shoe scanner, develop an automatic recognition algorithm for geometric design elements, test the scanner in locations around Ames. 6.2.2 CoNNOR: Convolutional Neural Network for Outsole Recognition Project Overview Label images of shoes according to geometric classification scheme Use convolutional base of pretrained CNN VGG16 and train a new classifier on labeled features Eventually, acquire real data passively and use CoNNOR to assess feature similarities and frequencies Link to submitted Creative Component on CoNNOR Github repository for paper submitted to Forensic Science International Exploring new directions: Truncate convolutional base and train random forest on features Could replace fully connected layers of neural net as classifier Importance score can filter/reduce the number of features Training the random forest requires too much memory for Bigfoot (CSAFE server), and still takes over two weeks on the HPC. We’re setting this goal aside for now, but could try subsampling the features for a random forest in the future. Spatial integration Model is currently set up to take in 256x256 pixels Try taking in full shoe using a sliding window of size 256x256 View class predictions spatially Fully convolutional networks (FCNs) Unsupervised segmentation to assess current classification scheme Handle whole shoe image of any size (instead of only 256x256 pixel images) References for CNNs and FCNs Stack Exchange post explaining patchwise training “Learning Hierarchical Features for Scene Labeling”: describes an application of multi-scale CNNs and image pyramids “Pyramid methods in image processing”: classic paper from 1984 explaining pyramid methods “Fully Convolutional Networks for Semantic Segmentation” “W-Net: A Deep Model for Fully Unsupervised Image Segmentation” 6.2.3 Spatial integration The overhead costs of going fully convolutional are high; CNN papers are opaque, and many supervised techniques require fully labeled data for semantic segmentation (i.e., label every pixel). Moreover, complex models (for both supervised and unsupervised tequniques) are often only available in Python, and there are a large number of GitHub repositories of mixed quality and reliability. Filtering for quality, understanding code structures, and implementing them on HPC are all enormous tasks on their own. In the meantime, it is much easier (relatively speaking) to use our existing framework of 256x256 square pixel images, for which we have generated thousands of labeled images and have already trained and improved domain-specific models. Currently, I have code working to automatically crop image borders, chop the image into 256x256 pixels (padding the image when appropriate) and equalize the contrast on the individual images. Pad the left and top of the image with a pre-specified offset, then chop the image into 256x256 pixel pieces Equalize the contrast channel for each piece of the image Use the trained model to predict each piece of the image for each class Repeat the above process for different cuts of the original image, and aggregate predictions Shiny App Updates/In progress: Presented on CoNNOR at ISU’s 3-Minute Thesis competition Preliminaries: 8 heats with 10-12 participants each Winner of each heat (announced today by 5 pm) will go on to finals next week Implementing semantic segmentation model on HPC Learning HPC structure, command line syntax, using Python in practice Documentation assumes high baseline of knowledge :( Improving spatial integration process Remove predictions for blank (and mostly blank) edge images Smooth predictions for overlapping image pieces Discovered bug this morning. Pictures coming soon! 6.3 Maximum Clique Matching 6.4 Project Tread (formerly Cocoa Powder Citizen Science) Project Tread, modified from Leverhulme Institute’s Sole Searching, is a developing CSAFE project with the goals of engaging community participation in forensic research and acquiring shoe print data that may be useful in future analyses. In progress: Review procedures and IRB documents written by James Perhaps modify procedures, then bribe some friends into helping me test them :) Test for length, clarity, ease, etc. Be involved in set up of data collection site (through CSSM) 6.4.0.1 Comparing the procedures Procedure Leverhulme CSAFE (initial) CSAFE (proposed) ‘Before’ Views 4 per shoe 5 per shoe 5 per shoe ‘Before’ Pictures 1 per view 3 per view 1 per view Total ‘before’ pics 4 per shoe 15 per shoe 5 per shoe Paper Letter (larger) Tape 8.5 x 11 Tape 8.5 x 11 Actions Run, jump, walk Step, hop Step, hop Replicates 6 per action 9 per action 3 per action ‘After’ Pictures 1 pic per rep. 3 pics per rep. 1 pic per rep. Total number prints 18 per shoe 18 per shoe 6 per shoe Total number images 18 per shoe 54 per shoe 6 per shoe Requested # shoes Not specified Both shoes One, 2nd optional Recommended procedure modifications: Ask for one high-quality image of each shoe angle (‘before’) and print (‘after’), instead of three replicate images of each If Project Tread submission website is set up like current CSSM system (which takes community submissions for environmental images), intermediate quality control can help filter out bad images Only ask for one shoe, and make second shoe optional E.g., always ask for left shoe, and make right shoe optional Ask for 3 replicates per shoe Longitudinal shoe study uses 2-3 replicates per shoe Next steps: Ask volunteers to test procedure by Monday, November 4th I believe Heike volunteered her children, and Joe reluctantly agreed to help. Anyone else? Pretty please? :D Ask Leverhulme how they use their data, what changes they would make, etc. First, currently checking with James to see if he already has this info. Talk to Alicia about how (or whether) CSAFE plans to use the data in any specific ways, to make sure procedure pruning doesn’t impede analysis 6.5 3d Shoe Recognition The set up: Note: With these alignment processes we are assuming that the shoe size does not change with wear and that we are not aligning across pairs of shoes. Then we want to look at the change overtime a specific shoe, so we need to grab the shoe scans over time. Using the function shoe_grab to grab the scans of a given shoe ID, specify the id number of a shoe you want to look at, (Make sure you have access to the data, follow the steps on the README for more information. For more information on the shoe data, see Longituidinal_Shoe_Study), and turns the given shoe into mesh objects to do further analysis. What we have tried: At first we wanted to try to simplify the mesh object to just the basic shape in order have simplicity when aligning. The idea of allignment is to take the most basic features, allign them, then by adding complexity of the soul, further allign the two different shoes. The idea is that we want to take a lower detail scan of shoe, allign it, then by adding complexity we can further allign the shoes. However the problem was realized that we are using a prediction to allign rather than the shoe, which ran into some quick problems. What we are doing now - Transforming the mesh objects to points aligned by the center of mass to overlay them detecting difference. - Problems - Isnt aligning properly as you can see - Next - angle transformations -PCA: This is working wiht the shoes that I have personally scanned, however still in the process of working on fixing them for the shoes of the longitudinal study. Once this occurs, need to figure out how to revert it to mesh objects agian. 6.6 Shoe outsole matching using image descriptors 6.6.1 Features Previously, features such as edge, corner, SURF were extracted to match shoeprints. The goal of this project is to find other image descriptors as image features for shoe print matching. Image descriptors SURF(Speeded Up Robust Features)- blobs KAZE - blobs ORB(Oriented FAST and Rotated BRIEF)- corners Image matching CSAFE data - Nike size of 10.5 and Adidas size of 10 will be used to construct mated and non-mated matching Features will be combination of strong 100 points of KAZE, ORB, SURF. 6.6.2 Matching on clean and full images Mates : Image (1) and (2) Non-mates : Image (1) and (3), Image (2) and (3) Performance evaluation using SURF 500 KAZE 500 ORB 500 SURF 100 + KAZE 100 + ORB 100 SURF 200 + KAZE 200 + ORB 200 POC (Phase-only correlation) FMTC (Fourier Mellon transformation correlation) Example graphs of mates: Example graphs of non-mates: Example matching table using SURF 500: Class Clique size Rotation angle % Overlap Median distance of OP Mates 18 2.11 0.5646 0.78 Non-mates 9 6.43 0.1208 1.39 Density plots: ROC curves on test comparisons: 6.6.3 Matching on degraded and partial images Example of degraded images: ROC curves on test comparisons: ROC curves when Q is degraded: What we plan to do: Get ROC curves using KASE, ORB, combination of them Do the same comparisons on degraded and partial impressions Submit the paper 6.7 Impact of weight to outsole scans from EverOS 2D scanner Analysis setup: Shoes: 5 pairs of Nike Winflow 4, size 10.5 (Brand-new shoes) Participants: Person 1 (weight aa lb)and person 2 (bb lb) Weights: 2 weight vests (20 lbs and 12 lbs) Weight variations: W1(P1), W2(P1 with one vest), W3(P1 with two vests), W4(P2), W5(P2 with one vest), W6(P2 with two vests) W1 \\(=\\) 155.2 lb, W2 \\(=\\) 173.8 lb, W3 \\(=\\) 187.6 lb, W4 \\(=\\) 178 lb, W5 \\(=\\) 197.4 lb, W6 \\(=\\) 211 lb Result1: Shoe is fixed to left side of shoe1. Result2: Purple, green: comparison between repeated replicates from the same shoe, W2-W2, W4-W4. Comparison between weights W2 and W4: weights are almost the same. Yellow: comparison when shoe is fixed to shoe1-L. Red: comparison between shoe1 – shoe2-5. Shoes are never used. References "],
["theoretical-foundations.html", "Chapter 7 Theoretical foundations 7.1 Common Source vs Specific Source Comparison via Information Theory 7.2 Score-based Likelihood Ratios are not Fundamentally “Incoherent” 7.3 Optimal matching problem", " Chapter 7 Theoretical foundations 7.1 Common Source vs Specific Source Comparison via Information Theory 7.1.1 Introduction Central Goals continue work started by Danica and Peter Vergeer on the analysis of likelihood ratios study the differences between specific source (SS) and common source (CS) likelihood ratios (LRs) in an information theoretic way does the CS or SS LR have more “information”? does the data (or the score) have more “information” about the SS or the CS hypothesis? can be the CS or SS hypotheses (prosecution or defense) be formally compared in terms of being easier to “prove” or “disprove”? General Notation Let \\(X \\in \\mathbb{R}^{q_x}\\) and \\(Y \\in \\mathbb{R}^{q_y}\\) be two random vectors with joint distribution \\(P\\) and corresponding density \\(p\\). : \\(\\mathbb{H}(X) = -\\int{p(x) \\log p(x) dx}\\) : \\(\\mathbb{H}(X|Y) = \\mathbb{E}_{Y}\\left[-\\int{p(x|y) \\log p(x|y) dx}\\right]\\) : \\(\\mathbb{H}_{2}(X|Y) = -\\int{p(x|y) \\log p(x|y) dx}\\) : \\(\\mathbb{I}(X;Y) = \\mathbb{H}(X) - \\mathbb{H}(X|Y)\\) Proof that Mutual Information is always positive: \\[\\begin{align*} \\mathbb{I}(X;Y) &amp;= \\mathbb{H}(X) - \\mathbb{H}(X|Y) \\\\ &amp;= -\\int{p(x) \\log p(x) dx} + \\int{\\int{p(x|y)p(y) \\log p(x|y) dx} dy} \\\\ &amp;= -\\int{\\int{p(x,y) \\log p(x) dx}dy} + \\int{\\int{p(x,y) \\log p(x|y) dx} dy} \\\\ &amp;= -\\int{\\int{p(x,y) \\log p(x) dx}dy} + \\int{\\int{p(x,y) \\log \\frac{p(x,y)}{p(y)} dx} dy} \\\\ &amp;= \\int{\\int{p(x,y) \\log \\frac{p(x,y)}{p(x)p(y)} dx}dy} \\\\ &amp;= KL(P||P_{X} \\times P_{Y}) \\\\ &amp;\\geq 0 \\end{align*}\\] 7.1.2 Common Source vs Specific Source LR The “common source” problem is to determine whether two pieces of evidence, both with unknown origin, have the same origin. One might be interested in this problem if two crimes were suspected to be linked, but no suspect has yet been identified. Alternatively, the “specific source” problem is to determine whether a fragment of evidence coming from an unknown source, such as evidence at a crime scene, has the same origin as a fragment of evidence of known origin, such as evidence collected directly from a suspect. Basic Setup \\(H \\in \\{ H_p, H_d \\}\\) as the random variable associated with the CS hypothesis. \\(A\\) and \\(B\\) are discrete r.v.’s representing two “sources” of evidence distributions for \\(A\\) and \\(B\\) defined conditionally based on the hypothesis SS hypothesis is represented by the conditional random variable \\(H|A\\) \\(X\\) is data coming from \\(A\\), \\(Y\\) is data coming from \\(B\\) compare information contained in \\((X,Y)\\) about \\(H\\) and \\(H|A\\) join density can be written as \\(p(X,Y,A,B,H) = p(X,Y|A,B)p(B|A,H)p(A|H)p(H)\\) Is there more information in a CS or SS LR? Let us examine this question in two different ways. Is the posterior entropy (given \\((X,Y)\\)) in the common source hypothesis smaller than that of the specific source hypothesis? In other words, would observing the specific value of \\(A\\) as well as the data make you more certain about \\(H\\) than just observing the data? Is the posterior entropy (given \\((X,Y)\\)) in the common source hypothesis smaller than the average (over possible values for \\((X,Y,A)\\)) posterior entropy of the specific source hypothesis? In other words, do you expect that, on average, observing the value of \\(A\\) as well as the data make you more certain about \\(H\\) than just observing the data? Answering the first question/interpretation, to me, requires proving that \\[ \\mathbb{H}_{2}(H|X,Y) - \\mathbb{H}_{2}(H|X,Y, A) \\geq 0 \\]. Answering the second question requires proving that \\[ \\mathbb{H}(H|X,Y) - \\mathbb{H}(H|X,Y, A) \\geq 0 \\]. Luckily, the second question is true due to the fact that \\[\\begin{align*} \\mathbb{H}(H|X,Y) - \\mathbb{H}(H|X,Y,A) &amp;= \\mathbb{E}_{(X,Y)} \\left[ - \\int{p(h,a|x,y) \\log p(h|x,y) d(h,a)} + \\int{p(h,a|x,y) \\log p(h|x,y,a) d(h,a)} \\right] \\\\ &amp;= - \\int{p(h,a|x,y)p(x,y) \\log \\frac{p(h,a|x,y)}{p(a|x,y)p(h|x,y)} d(h,x,y,a)} \\\\ &amp;= \\mathbb{E}_{(X,Y)} \\left[ KL(P_{(H,A)|(X,Y)}||P_{H|(X,Y)} \\times P_{A|(X,Y)}) \\right] \\geq 0 \\end{align*}\\] Whether or not \\(\\mathbb{H}_{2}(H|X,Y) - \\mathbb{H}_{2}(H|X,Y, A) \\geq 0\\) is not obvious. We have that \\[\\begin{align*} \\mathbb{H}_{2}(H|X,Y) - \\mathbb{H}_{2}(H|X,Y, A) &amp;= \\int{-p(h|x,y)\\log p(h|x,y) dh} - \\int{-p(h|x,y,a) \\log p(h|x,y,a) dh} \\\\ &amp;= \\frac{p(a)}{p(a|x,y)}\\int{-p(h|x,y,a)\\log p(h|x,y) dh} + \\int{p(h|x,y,a) \\log p(h|x,y,a) dh}\\\\ &amp;??? \\end{align*}\\] We can try and understand the value of \\(\\mathbb{H}_{2}(H|X,Y) - \\mathbb{H}_{2}(H|X,Y, A)\\) in terms of \\(\\frac{p(a)}{p(a|x,y)}\\). For example, if \\(\\frac{p(a)}{p(a|x,y)} \\geq 1\\), then \\(\\mathbb{H}_{2}(H|X,Y) - \\mathbb{H}_{2}(H|X,Y, A) \\geq 0\\). If \\(\\frac{p(a)}{p(a|x,y)} \\leq 1\\), then it is hard to say much about the value of \\(\\mathbb{H}_{2}(H|X,Y) - \\mathbb{H}_{2}(H|X,Y, A)\\). Is there more information in the data about the CS or SS hypothesis? Under the second scenario, we can study this question by looking at 7.1.3 Other notions of information Information in \\(Y\\) about \\(X\\): \\(\\int{p(x|y) \\log \\frac{p(x|y)}{p(x)} dx}\\) nonnegative Equal to zero when \\(X \\perp Y\\) needn’t integrate over \\(Y\\) (?) as opposed to entropy, information in a random variable requires another random variable to be “predicted”… this is fine in our situation as we have a natural candidate: \\(H_p\\) or \\(H_d\\) 7.1.4 Information Theoretic Specific Source Score Sufficiency Metric Consider the specific source problem. The following derivations are very similar to those in the “infinite alternative population” situation considered in the paper that Danica, Alicia, Jarad, and I submitted. Assuming \\(X \\perp Y|A,B\\) and both \\(X \\perp B|A\\) and \\(Y \\perp A|B\\), the LR is \\[\\begin{align*} LR &amp;= \\frac{p(x,y|A = a,B = a)}{p(x,y|A = a,B \\neq a)} \\\\ &amp;= \\frac{p(x|A = a)p(y|A = a, B = a)}{p(x|A = a)p(y|A = a, B \\neq a)} \\\\ &amp;= \\frac{p(y|A = a, B = a)}{p(y|A = a, B \\neq a)}. \\end{align*}\\] Thus, the LR depends only on the evidence from the unknown source, \\(Y\\). For a given score, \\(s\\), we can also write the LR in the following way, \\[\\begin{align*} LR = \\frac{p(y|A = a, B = a)}{p(y|A = a, B \\neq a)} &amp;= \\frac{p(s|y, A = a)p(y|A = a, B = a)}{p(s|y, A = a)p(y|A = a, B \\neq a)} \\\\ &amp;= \\frac{p(s|y, A = a, B = a)p(y|A = a, B = a)}{p(s|y, A = a, B \\neq a)p(y|A = a, B \\neq a)} \\\\ &amp;= \\frac{p(s,y|A = a, B = a)}{p(s,y|A = a, B \\neq a)} \\\\ &amp;= \\frac{p(y|s,A = a, B = a)p(s|A = a, B = a)}{p(y|s,A = a, B \\neq a)p(s|A = a, B \\neq a)}. \\end{align*}\\] Because \\(S|Y,A\\) is a function only of the known source evidence, \\(X\\), and because \\(X \\perp B|A\\), we have that \\(S \\perp B | Y, A\\). This means that \\(p(s|y, A = a, B = a) = p(s|y, A = a, B \\neq a)\\). Using these facts, we can then decompose the KL divergence of the data under the specific source prosecution hypothesis in the following way, \\[\\begin{align*} KL(P(X,Y|A &amp;= a, B = a)||P(X,Y|A = a, B \\neq a)) = E_{(X,Y)}\\left[ \\log \\frac{p(x,y|A = a,B = a)}{p(x,y|A = a,B \\neq a)} | A = a, B = a \\right] \\\\ &amp;= E_{Y}\\left[ \\log \\frac{p(y|A = a,B = a)}{p(y|A = a,B \\neq a)} | A = a, B = a \\right] \\\\ &amp;= E_{S}\\left[ E_{Y}\\left[ \\log \\frac{p(y|A = a,B = a)}{p(y|A = a,B \\neq a)} |s, A = a, B = a \\right] \\right] \\\\ &amp;= E_{S}\\left[ E_{Y}\\left[ \\log \\frac{p(y|s,A = a,B = a)}{p(y|s,A = a,B \\neq a)} + \\log \\frac{p(s|A = a, B = a)}{p(s|A = a, B \\neq a)} |s, A = a, B = a \\right] \\right] \\\\ &amp;= E_{S}\\left[ E_{Y}\\left[ \\log \\frac{p(y|s,A = a,B = a)}{p(y|s,A = a,B \\neq a)}|s, A = a, B = a \\right] \\right] + E_{S} \\left[ \\log \\frac{p(s|A = a, B = a)}{p(s|A = a, B \\neq a)} \\right] \\\\ &amp;= E_{S} \\left[ KL(P(Y|S,A = a,B = b) || P(Y|S, A = a, B \\neq a)) \\right] + KL(P(S|A = a, B = a)||P(S|A = a, B \\neq a)). \\end{align*}\\] This implies that \\(KL(P(X,Y|A = a, B = a)||P(X,Y|A = a, B \\neq a)) \\geq KL(P(S|A = a, B = a)||P(S|A = a, B \\neq a))\\). An additional consequence is that larger values of \\(KL(P(S|A = a, B = a)||P(S|A = a, B \\neq a))\\) imply smaller values of \\(E_{S} \\left[ KL(P(Y|S,A = a,B = b) || P(Y|S, A = a, B \\neq a)) \\right]\\). Because \\(KL(P(Y|S,A = a,B = b) || P(Y|S, A = a, B \\neq a))\\) is a nonnegative function in terms of \\(S\\), small values of \\(E_{S} \\left[ KL(P(Y|S,A = a,B = b) || P(Y|S, A = a, B \\neq a)) \\right]\\) imply small values (in some sense) of \\(KL(P(Y|S,A = a,B = b) || P(Y|S, A = a, B \\neq a))\\). For example, if the expectation is zero, then the (conditional) KL divergence is zero almost everywhere. Zero KL divergence implies that \\(P(Y|S,A = a,B = b) = P(Y|S,A = a,B \\neq b)\\), i.e. \\(S\\) is sufficient for the specific source hypothesis. All of this means that \\(KL(P(S|A = a, B = a)||P(S|A = a, B \\neq a))\\) and \\(KL(P(S|A = a, B \\neq a)||P(S|A = a, B = a))\\) are measures of the usefulness of the score which have direct ties to sufficiency. Estimates of these are always computable in practice, and they are intuitive targets to maximize. For example, if the score is a predicted class probability for “match”, the more discriminative the classifier, the more sufficient the score. 7.2 Score-based Likelihood Ratios are not Fundamentally “Incoherent” Concern has been raised in the literature on LRs about a desirable property supposedly inherently absent from specific-source SLRs. The property, dubbed “coherence”, intuitively says that given two mutually exhaustive hypotheses, \\(H_A\\) and \\(H_B\\), the likelihood ratio used to compare hypothesis A to hypothesis B should be the reciprocal of that used to compare hypothesis B to hypothesis A. I will argue that the claims about the inherent incoherency of SLRs is a result of thinking about SLRs too narrowly. Specifically, I will show that the arguments as to why SLRs are incoherent arise through the inappropriate comparison of SLRs based on different score functions. When one appropriately considers a single score function, incoherency is impossible. 7.2.1 Coherence Denote by \\(E \\in \\mathbb{R}^{n}\\) the vector of random variables describing all of the observed evidence or data which will be used to evaluate the relative likelihood of the two hypotheses. Define by \\(LR_{i,j} \\equiv \\frac{p(E|H_i)}{p(E|H_j)}\\) the likelihood ratio of hypothesis \\(i\\) to hypothesis \\(j\\). The coherency principal is satisfied if \\[ LR_{i,j} = \\frac{1}{LR_{j,i}} \\]. Likelihood ratios are fundamentally coherent, but what about score-based likelihood ratios? Denote by \\(s: \\mathbb{R}^n \\rightarrow \\mathbb{R}^{q}\\) a score function mapping the original data to Euclidean space of dimension \\(q\\) (typically \\(q = 1\\)). Similar to LRs, denote by \\(SLR_{i,j} \\equiv \\frac{p(s(E)|H_i)}{p(s(E)|H_j)}\\) the score-based likelihood ratio comparing hypothesis \\(i\\) to hypothesis \\(j\\). Clearly, in this general context SLRs are also coherent. 7.2.2 Problems with arguments showing SLRs are incoherent Let us examine the arguments presented in [REFS] to the incoherence of SLRs. These arguments stem from an example where there are two known sources of evidence say, source \\(A\\) and source \\(B\\), each producing data \\(e_A\\) and \\(e_B\\), respectively. Furthermore, assume that we have a third piece of evidence of unknown origin, \\(e_u\\), which must have come from either \\(A\\) or \\(B\\). We then wish to evaluate the support of the data for \\(H_A\\) or \\(H_B\\) defined as follows \\[\\begin{array}{cc} H_A: &amp; e_u \\text{ was generated from source } A \\\\ H_B: &amp; e_u \\text{ was generated from source } B. \\end{array}\\] In this case, we have \\(LR_{A,B} = \\frac{p(e_A, e_B, e_u|H_A)}{p(e_A, e_B, e_u|H_B)}\\). We make use of all available data in the formulation of the numerator and denominator densities. Under the assumptions that each fragment of evidence is independent under both hypothesis \\(A\\) and \\(B\\) as well as that \\(p(e_A,e_B|H_A) = p(e_A,e_B|H_B)\\), the LR reduces to \\(LR_{A,B} = \\frac{p(e_u|H_A)}{p(e_u|H_B)}\\). The second assumption is generally acceptable as the source of \\(e_u\\) ought to have no impact on the distribution of the evidence with known source. [REFS] then consider possible SLRs for this example. However, they make an assumption that the score is explicitly a function only of two fragments of evidence. That is, assuming the dimension of \\(e_i\\), \\(dim(e_i) = k\\), is constant for \\(i = A,B,u\\), their score maps \\(s:\\mathbb{R}^k \\times \\mathbb{R}^k \\rightarrow \\mathbb{R}\\). An common example of such a score is Euclidean distance, i.e. \\(s(x,y) = \\left[ \\sum_{i = 1}^{k}(x_i - y_i)^2 \\right]^{1/2}\\). Such a score makes perfect sense in a typical specific-source problem context in which only two fragments of evidence are considered: one from the known source and one from the unknown source. However, when one desires to create an SLR based on this score in this particular example, it is tempting to suggest that the natural SLR is \\(SLR_{A,B} = \\frac{p(s(e_A,e_u)|H_A)}{p(s(e_A,e_u)|H_B)}\\). Yet, the natural SLR if the hypotheses were reversed is \\(SLR_{B,A} = \\frac{p(s(e_B,e_u)|H_B)}{p(s(e_B,e_u)|H_A)}\\). Neither of these SLRs is the reciprocal of the other, and so the specific source SLR appears to be “incoherent”. This approach, however, should raise a red flag immediately. Why, in the full LR case, do we require that (simplifying model assumptions aside) the numerator and denominator densities be functions of all available data, but the score is not? Furthermore, if we consider these SLRs in the more general context of scores depending on all available data, we see that, in fact, what [REFS] define to be \\(SLR_{A,B}\\) and \\(SLR_{B,A}\\) turn out to be two different SLRs depending on two different scores. For clarity, we will use \\(s(\\cdot)\\) to denote scores which are explicitly functions of all observed data, and we will use \\(\\delta (\\cdot)\\) to denote score functions which are only a function of two fragments of evidence/data. Specifically, the score in \\(SLR_{A,B}\\) is \\(s_1(e_u,e_A,e_B) = \\delta(e_u,e_A)\\) and the score in \\(SLR_{B,A}\\) is \\(s_2(e_u,e_A,e_B) = \\delta(e_u,e_B)\\). While the functional form of the score in the two SLRs appears to be the same, clearly \\(s_1(e_u,e_A,e_B) \\neq s_2(e_u,e_A,e_B)\\). Thus, the two SLRs are simply two distinct quantities whose relationship needn’t be expected to be related anymore than if one had decided to use two different function forms of \\(\\delta(\\cdot,\\cdot)\\) in the two separate SLRs. One might ask how to reasonably construct an SLR which utilizes a (univariate) score other than a similarity metric for two fragments of evidence. One such example in this case would be \\(s(e_u, e_A, e_B) = \\frac{\\delta(e_u,e_A)}{\\delta(e_u,e_B)}\\). Intuitively, under \\(H_A\\), the numerator should be larger than the denominator, while under \\(H_B\\), the opposite should be true. 7.2.3 Example of a coherent SLR in the two source problem Suppose that our hypotheses are defined such that \\[ \\begin{array}{cc} H_A: &amp; e_u \\sim N(\\mu_A, \\sigma^2), e_A \\sim N(\\mu_A, \\sigma^2), e_B \\sim N(\\mu_B, \\sigma^2) \\\\ H_B: &amp; e_u \\sim N(\\mu_B, \\sigma^2), e_A \\sim N(\\mu_A, \\sigma^2), e_B \\sim N(\\mu_B, \\sigma^2), \\end{array} \\] where \\(e_u\\), \\(e_A\\), \\(e_B\\) are mutual independent under both \\(H_A\\) and \\(H_B\\). We will examine three different SLRs: \\(SLR^{(A)} \\equiv \\frac{p(s_1(E)|H_A)}{p(s_1(E)|H_B)}\\), \\(SLR^{(B)} \\equiv \\frac{p(s_2(E)|H_A)}{p(s_2(E)|H_B)}\\), and \\(SLR^* \\equiv \\frac{p(s_3(E)|H_A)}{p(s_3(E)|H_B)}\\), where \\[\\begin{align*} E &amp;= (e_u, e_A, e_B)^{\\top} \\\\ s_1(E) &amp;= \\log \\lVert e_u - e_A \\rVert^2 \\\\ s_2(E) &amp;= \\log \\lVert e_u - e_B \\rVert^2 \\\\ s_3(E) &amp;= \\log \\frac{\\lVert e_u - e_A \\rVert^2}{\\lVert e_u - e_B \\rVert^2} \\end{align*}\\] LR versus SLR scatterplots under hypothesis A and B using three types of SLRs: “coherent”, “incoherent” considering hypothesis A first, and “incoherent” considering hypothesis B first. RMSE Exp.Cond.KL score.KL true.KL type hypothesis 3.79 2.71 1.76 4.47 coherent A 3.86 2.77 1.74 4.51 coherent B 4.64 3.37 1.10 4.47 incoherent A A 3.94 3.22 1.29 4.51 incoherent A B 3.93 3.23 1.24 4.47 incoherent B A 4.73 3.44 1.07 4.51 incoherent B B 7.2.4 Possible Generalizations of Coherent SLRs to the Multisource Case It might be nice to, in general, be able to construct a reasonable score given a “similarity” score, \\(\\delta(\\cdot, \\cdot)\\) defined in terms of two pieces of evidence. I’ll propose a couple ways of doing this. First, suppose that instead of two sources, we now have \\(K\\) sources, one of which is the source of the evidence from an unknown source. The task is to compare the hypothesis that the unknown source evidence was generated by a specific source \\(A = a_x \\in \\mathcal{S} \\equiv \\{1, 2, ..., K\\}\\) to the hypothesis that the unknown source evidence was generated by any one of the other sources \\(B = b \\in \\mathcal{S} \\setminus a_x\\). Mathematically, \\[ \\begin{array}{cc} H_A: &amp; e_u \\text{ generated by } a_x \\\\ H_B: &amp; e_u \\text{ generated by some } b \\in \\mathcal{S} \\setminus a_x. \\end{array} \\] Let’s consider two possible scores, both of which will be based off of an accepted dissimilarity metric, \\(\\delta(\\cdot, \\cdot) \\geq 0\\). The first score that we will consider is \\[ S_1(e_u, e_1, ..., e_K) = \\log \\frac{\\delta(e_u, e_{a_x})}{ \\min_{b \\in \\mathcal{S} \\setminus a_x} \\delta(e_u, e_b) }. \\] The second score that we will consider is \\[ S_2(e_u, e_1, ..., e_K) = \\log \\frac{\\delta(e_u, e_{a_x})}{ \\sum_{b \\in \\mathcal{S} \\setminus a_x} w(b)\\delta(e_u, e_b) }, \\] where \\(w(b)\\) are weights with \\(\\sum_{b \\in \\mathcal{S} \\setminus a_x} w(b) = 1\\). Intuitively, the first score should perform well. The dissimilarity in the numerator should be compared with the smallest dissimilarity in $ a_x$. In the absence of other prior information, only the relative size of the numerator dissimilarity to the smallest dissimilarity of \\(b \\in \\mathcal{S} \\setminus a_x\\) should matter. The second score would likely be easier to study in terms of mathematical properties. For example, it might be possible to assume \\(E \\left[ \\delta(e_u, e_i) \\right] = \\mu_1 &lt; \\infty\\) if the source of \\(e_u\\) is that of \\(e_i\\) but that \\(E \\left[ \\delta(e_u, e_i) \\right] = \\mu_2 &lt; \\infty\\) if the sources are different. One might be able to show some type of consistency property if, instead of one copy of \\(E = (e_u, e_1, ..., e_K)^{\\top}\\), we now have \\(N\\) iid copies \\(E_i = (e_u, e_1, ..., e_K)^{\\top}_i\\). Then, using \\(\\frac{1}{N} \\sum_{i = 1}^{N} \\delta(e_{u_i}, e_{j_i})\\) in place of \\(\\delta(e_u, e_j)\\) yields the ability to use the law of large numbers. This may be impractical in any real life situation, but I consider the score here nonetheless. In more generality, there seems to be no reason why a multisource score couldn’t be constructed using an arbitrary summary statistic of the “similarity” scores computed between the unknown source evidence and the alternative population. 7.2.5 Multisource example For simplicity, we will again assume that all evidence is generated from independent, univariate Gaussian distributions. Specifically, \\[ \\begin{array}{ccc} H_p: &amp; e_u \\sim N(\\mu_K, \\sigma^2), &amp; e_i \\sim N(\\mu_i, \\sigma^2), i \\in \\{ 1,..., K \\} \\\\ H_d: &amp; e_u \\sim GMM(\\{\\mu_k\\}_{k = 1}^{K - 1}, \\{ \\pi_k \\}_{k = 1}^{K - 1}, \\sigma^2), &amp; e_i \\sim N(\\mu_i, \\sigma^2), i \\in \\{ 1,...,K \\} \\end{array}. \\] where all random variables are assumed to be independent conditional on each hypothesis. We will further assume that \\(\\mu_i \\stackrel{iid}{\\sim} N(0, \\tau^2), i \\in \\{ 1,..., K-1 \\}\\). log-LR versus log-SLR scatterplots under hypothesis P and D using three types of SLRs which correspond to using different statistics to aggregate dissimilarity scores in the alternative source population. We try min, average, and max, corresponding to rows 1-3, respectively. RMSE Exp.Cond.KL KL true.KL type hypothesis 3.1371 2.1718 2.2813 4.4527 min P 8.4669 5.1396 1.8487 6.9865 min D 3.4835 2.3965 2.0568 4.4527 avg P 7.6549 4.2336 2.7529 6.9865 avg D 3.8587 2.7198 1.7333 4.4527 max P 7.0711 4.1623 2.8250 6.9865 max D 7.2.6 Other Possible Viewpoints? I have assumed in the previous section that the order of consideration of hypotheses should not affect the ordering of the data vector \\(E = (e_u,e_A,e_B)\\) or of the ordering of these arguments to the score function. This seems reasonable, but perhaps [REFS] would argue that considering \\(H_A\\) first, \\(E = (e_u, e_A, e_B)\\) and \\(s(E) = s(e_u, e_A, e_B)\\), but considering \\(H_B\\) first, \\(E = (e_u, e_B, e_A)\\) and \\(s(E) = s(e_u, e_B, e_A)\\). In this case, \\(SLR_{A,B} \\neq \\frac{1}{SLR_{B,A}}\\) because we switch the order of arguments to the score from one SLR to the other. Note that, however, if we relax the independence assumptions of independence under either \\(H_A\\) or \\(H_B\\), then even the LR becomes “incoherent” because \\(\\frac{p(e_u, e_A, e_B|H_A)}{p(e_u, e_A, e_B|H_B)} \\neq \\frac{p(e_u, e_B, e_A|H_A)}{p(e_u, e_B, e_A|H_B)}\\) in general. It is true that the LR depends only on the evidence of the unknown source in this specific scenario, but that is a consequence of modeling assumptions and not of LR paradigmatic principals. 7.3 Optimal matching problem 7.3.1 Two groups case. Suppose there are two groups \\(\\pi_{1}\\) and \\(\\pi_{2}\\) with densities \\(f_{1}(x)\\) and \\(f_{2}(x)\\) on the support \\(x \\in T\\). Let \\(p_{1}\\) and \\(p_{2}\\) be the prior probabilities of groups \\(\\pi_{1}\\) and \\(\\pi_{2}\\), respectively. There are new observations \\(\\mbox{obs}_{1}\\) and \\(\\mbox{obs}_{2}\\) with measurements \\(x_{1}\\) and \\(x_{2}\\), respectively. The goal is to distinguish there the new observations are from the same group or not. That is to partition the space \\(T \\times T\\) in to \\(T_{m} \\cup T_{nm}\\), where we conclude \\(\\mbox{obs}_{1}\\) and \\(\\mbox{obs}_{2}\\) are from the same group if \\((x_{1}, x_{2})\\) falls into \\(T_{m}\\); and otherwise if \\((x_{1}, x_{2}) \\in T_{nm}\\). The two type errors: Matching error: \\((x_{1}, x_{2}) \\in T_{m}\\) if \\(\\mbox{obs}_{1} \\in \\pi_{1}, \\mbox{obs}_{2} \\in \\pi_{2}\\) or \\(\\mbox{obs}_{1} \\in \\pi_{2}, \\mbox{obs}_{2} \\in \\pi_{1}\\); Unmatching error: \\((x_{1}, x_{2}) \\in T_{um}\\) if \\(\\mbox{obs}_{1}, \\mbox{obs}_{2} \\in \\pi_{1}\\) or \\(\\mbox{obs}_{1}, \\mbox{obs}_{2} \\in \\pi_{2}\\). The probability of errors are: \\[P(\\mbox{Matching error}) = \\int_{T_{m}} \\{f_{1}(x_{1})f_{2}(x_{2}) + f_{2}(x_{1})f_{1}(x_{2})\\}p_{1}p_{2}dx_{1}dx_{2},\\] \\[P(\\mbox{Unmatching error}) = \\int_{T_{um}} \\{f_{1}(x_{1})f_{1}(x_{2})p_{1}^{2} + f_{2}(x_{1})f_{2}(x_{2})p_{2}^{2}\\}dx_{1}dx_{2}.\\] Consider the unweighted sum of those two error probabilities \\(P(\\mbox{error}) = P(\\mbox{Matching error}) + P(\\mbox{Unmatching error})\\). We have \\[P(\\mbox{error}) = \\int_{T_{m}} \\big[\\{f_{1}(x_{1})f_{2}(x_{2}) + f_{2}(x_{1})f_{1}(x_{2})\\}p_{1}p_{2} - \\{f_{1}(x_{1})f_{1}(x_{2})p_{1}^{2} + f_{2}(x_{1})f_{2}(x_{2})p_{2}^{2}\\}\\big]dx_{1}dx_{2} + C,\\] where \\(C\\) is a constant. The minimum of this error probability with respect to \\(T_{m}\\) occurs when \\[\\begin{equation} T_{m} = \\bigg\\{(x_{1}, x_{2}): \\frac{[f_{1}(x_{1})f_{2}(x_{2}) + f_{2}(x_{1})f_{1}(x_{2})]p_{1}p_{2}}{f_{1}(x_{1})f_{1}(x_{2})p_{1}^{2} + f_{2}(x_{1})f_{2}(x_{2})p_{2}^{2}} &lt; 1 \\bigg\\}. \\label{eq:Optimalrule1} \\end{equation}\\] This decision region is the optimal matching rule to minimize the probability of the matching errors. Note that \\[f_{1}(x_{1})f_{1}(x_{2})p_{1}^{2} + f_{2}(x_{1})f_{2}(x_{2})p_{2}^{2} - [f_{1}(x_{1})f_{2}(x_{2}) + f_{2}(x_{1})f_{1}(x_{2})]p_{1}p_{2} = \\{f_{1}(x_{1})p_{1} - f_{2}(x_{1})p_{2}\\}\\{f_{1}(x_{2})p_{1} - f_{2}(x_{2})p_{2}\\}.\\] The optimal region \\(T_{m}\\) in () is equivalent to \\[\\begin{eqnarray} \\frac{f_{1}(x_{1})}{f_{2}(x_{1})} &lt; \\frac{p_{2}}{p_{1}} &amp;\\mbox{and}&amp; \\frac{f_{1}(x_{2})}{f_{2}(x_{2})} &lt; \\frac{p_{2}}{p_{1}} \\ \\mbox{ or } \\nonumber \\\\ \\frac{f_{1}(x_{1})}{f_{2}(x_{1})} &gt; \\frac{p_{2}}{p_{1}} &amp;\\mbox{and}&amp; \\frac{f_{1}(x_{2})}{f_{2}(x_{2})} &gt; \\frac{p_{2}}{p_{1}}, \\label{eq:Optimalrule2} \\end{eqnarray}\\] which corresponds to the optimal classification rule. From (), the optimal matching rule is equivalent to the optimal classification rule as long as we conclude the observations matched from one group if they are classified to the same group. Normal distribution. As an example, assume \\(\\pi_{1}\\) and \\(\\pi_{2}\\) are from normal distributions with mean \\(\\mu_{1}\\) and \\(\\mu_{2}\\), and covariance \\(\\Sigma\\). Further assume the prioir probabilities are the same \\(p_{1} = p_{2} = 1 / 2\\). The optimal decision is to classify \\(x_{1}\\) and \\(x_{2}\\) into the same group if \\[\\begin{equation} \\frac{\\exp\\big[ \\{x_{2} - (\\mu_{1} + \\mu_{2}) / 2\\} \\Sigma^{-1} (\\mu_{2} - \\mu_{1}) \\big] + \\exp\\big[ \\{x_{1} - (\\mu_{1} + \\mu_{2}) / 2\\} \\Sigma^{-1} (\\mu_{2} - \\mu_{1}) \\big]} {1 + \\exp\\big[ \\{x_{1} + x_{2} - (\\mu_{1} + \\mu_{2})\\}&#39; \\Sigma^{-1} (\\mu_{2} - \\mu_{1}) \\big]} &lt; 1. \\label{eq:OptimalruleNormal1} \\end{equation}\\] It can be shown that the above inequality is equivalent to \\[\\begin{eqnarray} \\exp\\big[ \\{x_{2} - (\\mu_{1} + \\mu_{2}) / 2\\} \\Sigma^{-1} (\\mu_{2} - \\mu_{1}) \\big] &lt; 1 &amp;\\mbox{and}&amp; \\exp\\big[ \\{x_{1} - (\\mu_{1} + \\mu_{2}) / 2\\} \\Sigma^{-1} (\\mu_{2} - \\mu_{1}) \\big] &lt; 1 \\ \\mbox{ or } \\nonumber \\\\ \\exp\\big[ \\{x_{2} - (\\mu_{1} + \\mu_{2}) / 2\\} \\Sigma^{-1} (\\mu_{2} - \\mu_{1}) \\big] &gt; 1 &amp;\\mbox{and}&amp; \\exp\\big[ \\{x_{1} - (\\mu_{1} + \\mu_{2}) / 2\\} \\Sigma^{-1} (\\mu_{2} - \\mu_{1}) \\big] &gt; 1 \\label{eq:OptimalruleNormal2} \\end{eqnarray}\\] For discriminat analysis, it is well known that the optimal classification rule under normal distribution is to classify \\(x_{1}\\) and \\(x_{2}\\) to \\(\\pi_{1}\\) if \\(\\{x_{1} - (\\mu_{1} + \\mu_{2}) / 2\\} \\Sigma^{-1} (\\mu_{2} - \\mu_{1}) \\leq 0\\) and \\(\\{x_{2} - (\\mu_{1} + \\mu_{2}) / 2\\} \\Sigma^{-1} (\\mu_{2} - \\mu_{1}) \\leq 0\\) respectively, and classify them to \\(\\pi_{2}\\) if otherwise. Feature difference is a method to solve the matching problem via classification. Take \\(d = x_{1} - x_{2}\\) as the pairwise difference between two observations. It is clear that \\(d \\sim N(0, 2 \\Sigma)\\) if \\(x_{1}\\) and \\(x_{2}\\) are both from either \\(\\pi_{1}\\) or \\(\\pi_{2}\\), and \\(d \\sim N(\\mu_{1} - \\mu_{2}, 2 \\Sigma)\\) or \\(d \\sim N(\\mu_{2} - \\mu_{1}, 2 \\Sigma)\\) if \\(x_{1}\\) and \\(x_{2}\\) are from different groups. Let \\(f_{m}(d)\\) and \\(f_{um}(d)\\) be the density of \\(d\\) if two observations are from the same group and different groups, respectively. Then, \\(f_{m}(d)\\) is the normal density with mean \\(0\\) and covariance \\(2 \\Sigma\\), and \\(f_{um}(d)\\) is the mixture normal \\(0.5 N(\\mu_{1} - \\mu_{2}, 2 \\Sigma) + 0.5 N(\\mu_{2} - \\mu_{1}, 2 \\Sigma)\\). The optimal discriminant rule is to classify \\(d\\) into the unmatching case if \\[\\frac{f_{um}(d)}{f_{m}(d)} = \\frac{\\exp\\{-(d - \\mu_{1} + \\mu_{2})&#39; \\Sigma^{-1} (d - \\mu_{1} + \\mu_{2}) / 4\\} + \\exp\\{-(d + \\mu_{1} - \\mu_{2})&#39; \\Sigma^{-1} (d + \\mu_{1} - \\mu_{2}) / 4\\}}{2 \\exp(-d&#39; \\Sigma^{-1} d / 4)} &gt; \\frac{p_{1}^{2} + p_{2}^{2}}{2 p_{1} p_{2}}.\\] Let \\(\\mu_{d} = \\mu_{1} - \\mu_{2}\\). The above inequality is equivalent to \\[\\exp(d&#39; \\Sigma^{-1} \\mu_{d} / 2) + \\exp( - d&#39; \\Sigma^{-1} \\mu_{d} / 2) &gt; \\exp(\\mu_{d}&#39; \\Sigma^{-1} \\mu_{d} / 4) \\frac{p_{1}^{2} + p_{2}^{2}}{p_{1}p_{2}},\\] which is approximately equivalent to \\[|d&#39; \\Sigma^{-1} \\mu_{d}| / 2 &gt; \\mu_{d}&#39; \\Sigma^{-1} \\mu_{d} / 4 + \\log (p_{1}^{2} + p_{2}^{2}) - \\log(p_{1}p_{2}).\\] As an illustration, consider one dimensional feature space. Take \\(\\mu_{1} = 1, \\mu_{2} = -1, \\Sigma = 1\\), and \\(p_{1} = p_{2} = 0.5\\). Figure 1 shows the optimal matching rule and the optimal rule based on feature difference. We see that in this example the matching region from the feature difference method only overlaps a small fraction of that from the optimal matching rule, and there is a missing alignment for the feature difference method in the two small triangles at the origin. We also note that even though most of the pink area and the blue area in Figure 1 don’t overlap, the probabilities that the pair of data \\((x_{1}, x_{2})\\) falling into those non-overlapping regions could be small, especially if the absolute value of either coordinate is large. See the contours of multivariate normal distribution in Figure 1. Figure 7.1: Matching regions from the optimal rule (in pink) and the method based on feature difference (in blue). The contours of multivariate normal distribution with means \\((1, -1)\\) (unmatching case) and \\((1, 1)\\) (matching case) are marked in black and red, respectively, where the covariance is identity. Comparison with random forest. We also conducted a small scale simulation to compare the optimal matching rule with the random forest method applied on the feature difference. The traning data include 50 observations from \\(N(1, 1)\\) and \\(N(-1, 1)\\). There are additional 10 observations from each of the group serving as the testing data. We evaluate the percentage of the matching errors on the pairs of the testing data. We repeated the whole simulation 100 times. The accuracy rates are 0.762 and 0.708 for the optimal matching rule and the random forest applied on the differences of the measurements, respectively. 65% out of the 100 repetitions, the former method has higher accuracy than the latter method. 7.3.2 Topics needs exploration How to quantify the matching error rates when the training data only inlcude a small part of many potential groups? How training errors change as more and more features are collected (dimension \\(p\\) increases), where only a small fraction of those features carry useful signals (feature selection). "],
["outreach-activities.html", "Chapter 8 Outreach activities 8.1 Book on Forensic Science and Statistics", " Chapter 8 Outreach activities CSAFE has several ongoing outreach projects. 8.1 Book on Forensic Science and Statistics Project members: Kiegan Rice Alicia Carriquiry Hal Stern (UCI) General book outline: Chapter 1: Introduction Chapter 2: Analysis of Forensic Evidence Drafted. In the editing stage. Chapter 3: The Path to the Witness Stand Drafted. In the editing stage. Chapter 4: Communicating Evidence in the Courtroom Not drafted. In the writing stage. Chapter 5: Conclusions "],
["references.html", "References", " References "]
]
